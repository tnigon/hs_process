<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="python">
  <head>
    <meta charset="utf-8" />
    <title>hs_process.batch &#8212; hs_process 0.0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          hs_process</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="https://github.com/tnigon/hs_process">Github</a></li>
                <li><a href="http://www.spectralpython.net/">Spectral Python</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Contents <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Home</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html">1. Setup and Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial_hsio.html">2. Tutorial: <code class="docutils literal notranslate"><span class="pre">hsio</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial_hstools.html">3. Tutorial: <code class="docutils literal notranslate"><span class="pre">hstools</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial_segment.html">4. Tutorial: <code class="docutils literal notranslate"><span class="pre">segment</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial_spec_mod.html">5. Tutorial: <code class="docutils literal notranslate"><span class="pre">spec_mod</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial_spatial_mod.html">6. Tutorial: <code class="docutils literal notranslate"><span class="pre">spatial_mod</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorial_batch.html">7. Tutorial: <code class="docutils literal notranslate"><span class="pre">batch</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../../my_hs_process_api.html">8. API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../api/hs_process.batch.html">8.1.1. batch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/hs_process.defaults.html">8.1.2. defaults</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/hs_process.hsio.html">8.1.3. hsio</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/hs_process.hstools.html">8.1.4. hstools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/hs_process.segment.html">8.1.5. segment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/hs_process.spatial_mod.html">8.1.6. spatial_mod</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../api/hs_process.spec_mod.html">8.1.7. spec_mod</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../license.html">9. License</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html">10. Change Log</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">1. Setup and Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial_hsio.html">2. Tutorial: <code class="docutils literal notranslate"><span class="pre">hsio</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial_hstools.html">3. Tutorial: <code class="docutils literal notranslate"><span class="pre">hstools</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial_segment.html">4. Tutorial: <code class="docutils literal notranslate"><span class="pre">segment</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial_spec_mod.html">5. Tutorial: <code class="docutils literal notranslate"><span class="pre">spec_mod</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial_spatial_mod.html">6. Tutorial: <code class="docutils literal notranslate"><span class="pre">spatial_mod</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial_batch.html">7. Tutorial: <code class="docutils literal notranslate"><span class="pre">batch</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../my_hs_process_api.html">8. API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api/hs_process.batch.html">8.1.1. batch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/hs_process.defaults.html">8.1.2. defaults</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/hs_process.hsio.html">8.1.3. hsio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/hs_process.hstools.html">8.1.4. hstools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/hs_process.segment.html">8.1.5. segment</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/hs_process.spatial_mod.html">8.1.6. spatial_mod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/hs_process.spec_mod.html">8.1.7. spec_mod</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">9. License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">10. Change Log</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary">
<form action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <h1>Source code for hs_process.batch</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="kn">from</span> <span class="nn">hs_process.utilities</span> <span class="kn">import</span> <span class="n">defaults</span>
<span class="kn">from</span> <span class="nn">hs_process.utilities</span> <span class="kn">import</span> <span class="n">hsio</span>
<span class="kn">from</span> <span class="nn">hs_process.segment</span> <span class="kn">import</span> <span class="n">segment</span>
<span class="kn">from</span> <span class="nn">hs_process.spec_mod</span> <span class="kn">import</span> <span class="n">spec_mod</span>
<span class="kn">from</span> <span class="nn">hs_process.spatial_mod</span> <span class="kn">import</span> <span class="n">spatial_mod</span>


<div class="viewcode-block" id="batch"><a class="viewcode-back" href="../../api/hs_process.batch.html#hs_process.batch">[docs]</a><span class="k">class</span> <span class="nc">batch</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Class for batch processing hyperspectral image data. Makes use of</span>
<span class="sd">    `segment`_, `spatial_mod`_, and `spec_mod`_ to batch process many</span>
<span class="sd">    datacubes in a given directory. Supports options to save full</span>
<span class="sd">    datacubes, geotiff renders, as well as summary statistics and/or</span>
<span class="sd">    reports for the various tools.</span>

<span class="sd">    Note:</span>
<span class="sd">        It may be a good idea to review and understand the `defaults`_,</span>
<span class="sd">        `hsio`_, `hstools`_, `segment`_, `spatial_mod`_, and `spec_mod`_</span>
<span class="sd">        classes prior to using the ``batch`` module.</span>

<span class="sd">    .. _defaults: hs_process.defaults.html</span>
<span class="sd">    .. _hsio: hs_process.hsio.html</span>
<span class="sd">    .. _hstools: hs_process.hstools.html</span>
<span class="sd">    .. _segment: hs_process.segment.html</span>
<span class="sd">    .. _spatial_mod: hs_process.spatial_mod.html</span>
<span class="sd">    .. _spec_mod: hs_process.spec_mod.html</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">search_ext</span><span class="o">=</span><span class="s1">&#39;.bip&#39;</span><span class="p">,</span> <span class="n">dir_level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters:</span>
<span class="sd">            base_dir (``str``, optional): directory path to search for files to</span>
<span class="sd">                spectrally clip; if ``fname_list`` is not ``None``, ``base_dir`` will</span>
<span class="sd">                be ignored (default: ``None``).</span>
<span class="sd">            search_ext (``str``): file format/extension to search for in all</span>
<span class="sd">                directories and subdirectories to determine which files to</span>
<span class="sd">                process; if ``fname_list`` is not ``None``, ``search_ext`` will</span>
<span class="sd">                be ignored (default: &#39;bip&#39;).</span>
<span class="sd">            dir_level (``int``): The number of directory levels to search; if</span>
<span class="sd">                ``None``, searches all directory levels (default: 0).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_dir</span> <span class="o">=</span> <span class="n">base_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search_ext</span> <span class="o">=</span> <span class="n">search_ext</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dir_level</span> <span class="o">=</span> <span class="n">dir_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fname_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">io</span> <span class="o">=</span> <span class="n">hsio</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">my_spectral_mod</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">my_spatial_mod</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">my_segment</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_try_spat_crop_col_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">df_row</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Gets value of batch.io.defaults.spat_crop_cols[``key``]; returns</span>
<span class="sd">        ``None`` if there is a KeyError</span>

<span class="sd">        Adds ``key`` to batch.io.defaults.spat_crop_cols if it does not yet</span>
<span class="sd">        exist, but then of course the ``value`` that is returned will be</span>
<span class="sd">        ``None``</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">spat_crop_cols</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">spat_crop_cols</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">df_row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">spat_crop_cols</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>  <span class="c1"># try to retrieve a default value</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">crop_defaults</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_check_processed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span>
                         <span class="n">name_append</span><span class="p">,</span> <span class="n">append_extra</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Checks if any files in fname_list have already (presumably) undergone</span>
<span class="sd">        processing. This is determined by checking if a file exists with a</span>
<span class="sd">        particular name based on the filename in fname_list and naming</span>
<span class="sd">        parameters (i.e,. ``folder_name`` and ``name_append``).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">append_extra</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">append_extra</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">fname_list_final</span> <span class="o">=</span> <span class="n">fname_list</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fname_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">base_dir_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">base_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fname</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                        <span class="n">base_dir</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                        <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
            <span class="n">name_print</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_name_print</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

            <span class="n">name_label</span> <span class="o">=</span> <span class="p">(</span><span class="n">name_print</span> <span class="o">+</span> <span class="n">name_append</span> <span class="o">+</span> <span class="n">append_extra</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span><span class="p">)):</span>
                <span class="n">fname_list_final</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;There are no files to process. Please check if files have &#39;</span>
               <span class="s1">&#39;already undergone processing. If existing files should be &#39;</span>
               <span class="s1">&#39;overwritten, be sure to set the ``out_force`` parameter.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fname_list_final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">msg</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Processing </span><span class="si">{0}</span><span class="s1"> files. If this is not what is expected, please &#39;</span>
              <span class="s1">&#39;check if files have already undergone processing. If existing &#39;</span>
              <span class="s1">&#39;files should be overwritten, be sure to set the ``out_force`` &#39;</span>
              <span class="s1">&#39;parameter.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fname_list_final</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">fname_list_final</span>

    <span class="k">def</span> <span class="nf">_crop_read_sheet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Reads the necessary information from the spreadsheet and saves it</span>
<span class="sd">        to a dictionary</span>

<span class="sd">        If this function causes an error, try checking</span>
<span class="sd">        ``batch.io.defaults.spat_crop_col`` - these should be adjusted</span>
<span class="sd">        according to the default column names of the input (i.e.,</span>
<span class="sd">        ``fname_sheet``).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">crop_specs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;directory&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;directory&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;fname&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;fname&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;name_short&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;name_short&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;name_long&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;name_long&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;ext&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;ext&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;pix_e_ul&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;pix_e_ul&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;pix_n_ul&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;pix_n_ul&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;plot_id&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;plot_id&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;alley_size_e_m&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;alley_size_e_m&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;alley_size_n_m&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;alley_size_n_m&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;alley_size_e_pix&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;alley_size_e_pix&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;alley_size_n_pix&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;alley_size_n_pix&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;buf_e_m&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;buf_e_m&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;buf_n_m&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;buf_n_m&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;buf_e_pix&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;buf_e_pix&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;buf_n_pix&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;buf_n_pix&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;crop_e_m&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;crop_e_m&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;crop_n_m&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;crop_n_m&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;crop_e_pix&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;crop_e_pix&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;crop_n_pix&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;crop_n_pix&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;n_plots_x&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;n_plots_x&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;n_plots_y&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;n_plots_y&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="s1">&#39;n_plots&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_try_spat_crop_col_key</span><span class="p">(</span><span class="s1">&#39;n_plots&#39;</span><span class="p">,</span> <span class="n">row</span><span class="p">)}</span>
        <span class="k">if</span> <span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;name_short&#39;</span><span class="p">]</span> <span class="o">+</span>
                                       <span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;name_long&#39;</span><span class="p">]</span> <span class="o">+</span>
                                       <span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;ext&#39;</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;name_short&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;name_short&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_name</span><span class="p">[</span>
                        <span class="p">:</span><span class="n">base_name</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">base_name</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">))]</span>
            <span class="k">if</span> <span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;name_long&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;name_long&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_name</span><span class="p">[</span>
                        <span class="n">base_name</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">base_name</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)):]</span>
            <span class="k">if</span> <span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;ext&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;ext&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">row</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">spat_crop_cols</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">crop_specs</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;name_long&#39;</span><span class="p">]):</span>
            <span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;name_long&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;plot_id&#39;</span><span class="p">]):</span>
            <span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;plot_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;name_short&#39;</span><span class="p">]):</span>
            <span class="n">crop_specs</span><span class="p">[</span><span class="s1">&#39;name_short&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">crop_specs</span> <span class="o">=</span> <span class="n">crop_specs</span>
        <span class="k">return</span> <span class="n">crop_specs</span>

    <span class="k">def</span> <span class="nf">_pix_to_mapunit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crop_specs</span><span class="p">,</span> <span class="n">spyfile</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Looks over specifications of ``crop_specs``, and converts betweeen pixel</span>
<span class="sd">        units and map units if one is populated and the other is ``None``</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="n">crop_specs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">spyfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spyfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span>
        <span class="n">spy_ps_e</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">spyfile</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;map info&#39;</span><span class="p">][</span><span class="mi">5</span><span class="p">])</span>
        <span class="n">spy_ps_n</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">spyfile</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;map info&#39;</span><span class="p">][</span><span class="mi">6</span><span class="p">])</span>
        <span class="c1"># Crop size</span>
<span class="c1">#        if cs[&#39;crop_e_pix&#39;] is None and cs[&#39;crop_e_m&#39;] is not None:</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_e_pix&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_e_m&#39;</span><span class="p">]):</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_e_pix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_e_m&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">spy_ps_e</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_e_pix&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_e_m&#39;</span><span class="p">]):</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_e_m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_e_pix&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">spy_ps_e</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_n_pix&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_n_m&#39;</span><span class="p">]):</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_n_pix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_n_m&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">spy_ps_n</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_n_pix&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_n_m&#39;</span><span class="p">]):</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_n_m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_n_pix&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">spy_ps_n</span>
        <span class="c1"># Buffer</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_e_pix&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_e_m&#39;</span><span class="p">]):</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_e_pix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_e_m&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">spy_ps_e</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_e_pix&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_e_m&#39;</span><span class="p">]):</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_e_m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_e_pix&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">spy_ps_e</span>
        <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_n_pix&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_n_m&#39;</span><span class="p">]):</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_n_pix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_n_m&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">spy_ps_e</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_n_pix&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_n_m&#39;</span><span class="p">]):</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_n_m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_n_pix&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">spy_ps_e</span>
        <span class="c1"># Alley size</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_e_pix&#39;</span><span class="p">])</span> <span class="ow">and</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_e_m&#39;</span><span class="p">])):</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_e_pix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_e_m&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">spy_ps_e</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_e_pix&#39;</span><span class="p">])</span> <span class="ow">and</span>
                  <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_e_m&#39;</span><span class="p">])):</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_e_m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_e_pix&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">spy_ps_e</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_n_pix&#39;</span><span class="p">])</span> <span class="ow">and</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_n_m&#39;</span><span class="p">])):</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_n_pix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_n_m&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">spy_ps_n</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_n_pix&#39;</span><span class="p">])</span> <span class="ow">and</span>
                  <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_n_m&#39;</span><span class="p">])):</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_n_m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_n_pix&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">spy_ps_n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crop_specs</span> <span class="o">=</span> <span class="n">cs</span>
        <span class="k">return</span> <span class="n">cs</span>

    <span class="k">def</span> <span class="nf">_band_math_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">name_append</span><span class="p">,</span>
                         <span class="n">method</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;``method`` must be one of either &quot;ndi&quot;, &quot;ratio&quot;, &quot;derivative&quot;, &#39;</span>
               <span class="s1">&#39;or &quot;mcari2&quot;.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ndi&#39;</span><span class="p">,</span> <span class="s1">&#39;ratio&#39;</span><span class="p">,</span> <span class="s1">&#39;derivative&#39;</span><span class="p">,</span> <span class="s1">&#39;mcari2&#39;</span><span class="p">],</span> <span class="n">msg</span>

        <span class="k">if</span> <span class="n">base_dir_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                    <span class="n">base_dir</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                    <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
        <span class="n">name_print</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_name_print</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ndi&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Calculating normalized difference index for: </span><span class="si">{0}</span><span class="s1">&#39;</span>
                  <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name_print</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ratio&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Calculating simple ratio index for: </span><span class="si">{0}</span><span class="s1">&#39;</span>
                  <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name_print</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_print</span><span class="p">,</span> <span class="n">name_append</span>

    <span class="k">def</span> <span class="nf">_execute_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_list</span><span class="p">,</span> <span class="n">mask_dir</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span>
                      <span class="n">name_append</span><span class="p">,</span> <span class="n">geotiff</span><span class="p">,</span> <span class="n">mask_thresh</span><span class="p">,</span> <span class="n">mask_percentile</span><span class="p">,</span>
                      <span class="n">mask_side</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Actually creates the mask to keep the main function a bit cleaner</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">mask_thresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask_percentile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">type_mask</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-thresh-</span><span class="si">{1}</span><span class="s1">-pctl-</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">mask_side</span><span class="p">,</span> <span class="n">mask_thresh</span><span class="p">,</span> <span class="n">mask_percentile</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">mask_thresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask_percentile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">type_mask</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-thresh-</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">mask_side</span><span class="p">,</span> <span class="n">mask_thresh</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">mask_thresh</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask_percentile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">type_mask</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-pctl-</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">mask_side</span><span class="p">,</span> <span class="n">mask_percentile</span><span class="p">))</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">,</span> <span class="s1">&#39;plot_id&#39;</span><span class="p">,</span> <span class="n">type_mask</span><span class="p">]</span>
        <span class="n">df_stats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fname_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_cube</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">metadata_geotiff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">base_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">base_dir_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                        <span class="n">base_dir</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                        <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
            <span class="n">name_print</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_name_print</span><span class="p">()</span>
            <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">mask_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mask_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">base_dir</span><span class="p">,</span> <span class="s1">&#39;band_math&#39;</span><span class="p">)</span>
            <span class="n">array_bandmath</span><span class="p">,</span> <span class="n">metadata_bandmath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_array_similar</span><span class="p">(</span>
                    <span class="n">mask_dir</span><span class="p">)</span>
<span class="c1">#            array_bandmath = np.ma.masked_array(</span>
<span class="c1">#                    array_bandmath, mask=array_kmeans.mask)</span>
            <span class="n">array_mask</span><span class="p">,</span> <span class="n">metadata_bandmath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">mask_array</span><span class="p">(</span>
                    <span class="n">array_bandmath</span><span class="p">,</span> <span class="n">metadata_bandmath</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="n">mask_thresh</span><span class="p">,</span>
                    <span class="n">percentile</span><span class="o">=</span><span class="n">mask_percentile</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">mask_side</span><span class="p">)</span>

            <span class="n">stat_mask_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">array_mask</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">fname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">name_plot</span><span class="p">,</span> <span class="n">stat_mask_mean</span><span class="p">]</span>
            <span class="n">df_stats_temp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">data</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">df_stats</span> <span class="o">=</span> <span class="n">df_stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_stats_temp</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">spec_mean</span><span class="p">,</span> <span class="n">spec_std</span><span class="p">,</span> <span class="n">datacube_masked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">mean_datacube</span><span class="p">(</span>
                    <span class="n">array</span><span class="p">,</span> <span class="n">array_mask</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
<span class="c1">#            metadata = self.io.spyfile.metadata.copy()</span>
            <span class="c1"># because this is specialized, we should make our own history str</span>
            <span class="n">hist_str</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot; -&gt; hs_process.batch.segment_create_mask[&lt;&quot;</span>
                        <span class="s2">&quot;label: &#39;mask_thresh?&#39; value:</span><span class="si">{0}</span><span class="s2">; &quot;</span>
                        <span class="s2">&quot;label: &#39;mask_percentile?&#39; value:</span><span class="si">{1}</span><span class="s2">; &quot;</span>
                        <span class="s2">&quot;label: &#39;mask_side?&#39; value:</span><span class="si">{2}</span><span class="s2">&gt;]&quot;</span>
                        <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mask_thresh</span><span class="p">,</span> <span class="n">mask_percentile</span><span class="p">,</span> <span class="n">mask_side</span><span class="p">))</span>
            <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hist_str</span>
            <span class="n">metadata_geotiff</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hist_str</span>

            <span class="n">name_label</span> <span class="o">=</span> <span class="p">(</span><span class="n">name_print</span> <span class="o">+</span> <span class="n">name_append</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_datacube</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span><span class="p">,</span> <span class="n">datacube_masked</span><span class="p">,</span>
                                 <span class="n">metadata</span><span class="p">)</span>
            <span class="n">name_label_spec</span> <span class="o">=</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">name_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                               <span class="s1">&#39;-spec-mean.spec&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_spec</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label_spec</span><span class="p">,</span> <span class="n">spec_mean</span><span class="p">,</span> <span class="n">spec_std</span><span class="p">,</span>
                             <span class="n">metadata</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">array_mask</span> <span class="o">=</span> <span class="n">array_mask</span>
            <span class="k">if</span> <span class="n">geotiff</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_geotiff</span><span class="p">(</span><span class="n">array_mask</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span><span class="p">,</span>
                                    <span class="n">metadata_geotiff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tools</span><span class="p">)</span>
<span class="c1">#        n = 1  # because multiple mask events may take place in same folder..</span>
<span class="c1">#        fname_csv = &#39;mask-stats.csv&#39;.format(str(n).zfill(3))</span>
<span class="c1">#        fname_csv_full = os.path.join(dir_out, fname_csv)</span>
<span class="c1">#</span>
<span class="c1">#        while os.path.isfile(fname_csv_full):</span>
<span class="c1">#            n += 1</span>
<span class="c1">#            fname_csv = &#39;mask-stats-{0}.csv&#39;.format(str(n).zfill(3))</span>
<span class="c1">#            dir_name, base_name = os.path.split(fname_csv_full)</span>
<span class="c1">##            base_name, ext = os.path.split(base_name)</span>
<span class="c1">#            fname_csv_full = os.path.join(dir_name, fname_csv)</span>
        <span class="n">fname_csv</span> <span class="o">=</span> <span class="s1">&#39;mask-stats.csv&#39;</span>
        <span class="n">fname_csv_full</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">fname_csv</span><span class="p">)</span>
        <span class="n">df_stats</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fname_csv_full</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1">#############################################</span>
<span class="c1">#</span>
<span class="c1">#            name_label_bm = (name_print + name_append + &#39;-{0}-{1}-{2}.&#39;</span>
<span class="c1">#                             &#39;&#39;.format(method, int(np.mean(wl1)),</span>
<span class="c1">#                                       int(np.mean(wl2))) +</span>
<span class="c1">#                             self.io.defaults.envi_write.interleave)</span>
<span class="c1">#            meta_bm[&#39;label&#39;] = name_label_bm</span>
<span class="c1">#</span>
<span class="c1">#            if mask_thresh is not None or mask_percentile is not None:</span>
<span class="c1">#                array_bm, meta_bm = self.my_segment.tools.mask_array(</span>
<span class="c1">#                        array_bm, metadata, thresh=mask_thresh,</span>
<span class="c1">#                        percentile=mask_percentile, side=mask_side)</span>
<span class="c1">#                name_lab_dc = (name_print + &#39;-{0}-mask-{1}-{2}.&#39;</span>
<span class="c1">#                               &#39;&#39;.format(method, int(np.mean(wl1)),</span>
<span class="c1">#                                         int(np.mean(wl2))) +</span>
<span class="c1">#                               self.io.defaults.envi_write.interleave)</span>
<span class="c1">#            # should we make an option to save a mean spectra as well?</span>
<span class="c1">#            # Yes - we aren&#39;t required to save intermediate results and do</span>
<span class="c1">#            # another batch process..? we get everything done in one shot -</span>
<span class="c1">#            # after all, why do we want to do band math if we aren&#39;t also</span>
<span class="c1">#            # calculating the average of the area (unless cropping hasn&#39;t</span>
<span class="c1">#            # been perfomed yet)?</span>
<span class="c1">#            # No - Keep it simpler and keep batch functions more specific in</span>
<span class="c1">#            # their capabilities (e.g., batch.band_math, batch.mask_array,</span>
<span class="c1">#            # batch.veg_spectra)</span>
<span class="c1">#</span>
<span class="c1">#            if np.ma.is_masked(array_bm):</span>
<span class="c1">#                # don&#39;t pass thresh, etc. because array is already masked</span>
<span class="c1">#                # pass the spyfile for the metadata (tainted from threshold)</span>
<span class="c1">#                self.io.read_cube(fname)  # read again to get fresh metadata</span>
<span class="c1">#                self.io.spyfile.metadata[&#39;history&#39;] = meta_bm[&#39;history&#39;]</span>
<span class="c1">#                spec_mean, spec_std, datacube_masked, datacube_md =\</span>
<span class="c1">#                    self.my_segment.veg_spectra(</span>
<span class="c1">#                            array_bm, spyfile=self.io.spyfile)</span>
<span class="c1">#                if save_datacube is True:</span>
<span class="c1">#                    hdr_file = os.path.join(dir_out, name_lab_dc + &#39;.hdr&#39;)</span>
<span class="c1">#                    self.io.write_cube(hdr_file, datacube_masked,</span>
<span class="c1">#                                       dtype=self.io.defaults.envi_write.dtype,</span>
<span class="c1">#                                       force=self.io.defaults.envi_write.force,</span>
<span class="c1">#                                       ext=self.io.defaults.envi_write.ext,</span>
<span class="c1">#                                       interleave=self.io.defaults.envi_write.interleave,</span>
<span class="c1">#                                       byteorder=self.io.defaults.envi_write.byteorder,</span>
<span class="c1">#                                       metadata=datacube_md)</span>
<span class="c1">#                if save_spec is True:</span>
<span class="c1">#                    spec_md = datacube_md.copy()</span>
<span class="c1">#                    name_label_spec = (os.path.splitext(name_lab_dc)[0] +</span>
<span class="c1">#                                       &#39;-spec-mean.spec&#39;)</span>
<span class="c1">#                    spec_md[&#39;label&#39;] = name_label_spec</span>
<span class="c1">#                    hdr_file = os.path.join(dir_out, name_label_spec + &#39;.hdr&#39;)</span>
<span class="c1">#                    self.io.write_spec(hdr_file, spec_mean, spec_std,</span>
<span class="c1">#                                       dtype=self.io.defaults.envi_write.dtype,</span>
<span class="c1">#                                       force=self.io.defaults.envi_write.force,</span>
<span class="c1">#                                       ext=self.io.defaults.envi_write.ext,</span>
<span class="c1">#                                       interleave=self.io.defaults.envi_write.interleave,</span>
<span class="c1">#                                       byteorder=self.io.defaults.envi_write.byteorder,</span>
<span class="c1">#                                       metadata=spec_md)</span>
<span class="c1">#            self._write_datacube(dir_out, name_label_bm, array_bm, metadata)</span>
<span class="c1">#            if geotiff is True:</span>
<span class="c1">#                self._write_geotiff(array_bm, fname, dir_out, name_label_bm,</span>
<span class="c1">#                                    meta_bm, self.my_segment.tools)</span>

    <span class="k">def</span> <span class="nf">_execute_band_math</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span>
                           <span class="n">name_append</span><span class="p">,</span> <span class="n">geotiff</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">wl1</span><span class="p">,</span> <span class="n">wl2</span><span class="p">,</span> <span class="n">wl3</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span>
                           <span class="n">b3</span><span class="p">,</span> <span class="n">list_range</span><span class="p">,</span> <span class="n">plot_out</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Actually executes the band math to keep the main function a bit</span>
<span class="sd">        cleaner</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ndi&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ratio&#39;</span><span class="p">:</span>
            <span class="n">type_bm</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">-</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl1</span><span class="p">)),</span>
                                            <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl2</span><span class="p">))))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;derivative&#39;</span><span class="p">:</span>
            <span class="n">type_bm</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">-</span><span class="si">{2}</span><span class="s1">-</span><span class="si">{3}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl1</span><span class="p">)),</span>
                                                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl2</span><span class="p">)),</span>
                                                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl2</span><span class="p">))))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mcari2&#39;</span><span class="p">:</span>
            <span class="n">type_bm</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">-</span><span class="si">{2}</span><span class="s1">-</span><span class="si">{3}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl1</span><span class="p">)),</span>
                                                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl2</span><span class="p">)),</span>
                                                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl2</span><span class="p">))))</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">,</span> <span class="s1">&#39;plot_id&#39;</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;std_dev&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;pctl_10th&#39;</span><span class="p">,</span> <span class="s1">&#39;pctl_25th&#39;</span><span class="p">,</span> <span class="s1">&#39;pctl_50th&#39;</span><span class="p">,</span> <span class="s1">&#39;pctl_75th&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;pctl_90th&#39;</span><span class="p">,</span> <span class="s1">&#39;pctl_95th&#39;</span><span class="p">]</span>
        <span class="n">df_stats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fname_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_cube</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_print</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_band_math_setup</span><span class="p">(</span>
                    <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">name_append</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">my_segment</span> <span class="o">=</span> <span class="n">segment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ndi&#39;</span><span class="p">:</span>
                <span class="n">array_bm</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_segment</span><span class="o">.</span><span class="n">band_math_ndi</span><span class="p">(</span>
                        <span class="n">wl1</span><span class="o">=</span><span class="n">wl1</span><span class="p">,</span> <span class="n">wl2</span><span class="o">=</span><span class="n">wl2</span><span class="p">,</span> <span class="n">b1</span><span class="o">=</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="o">=</span><span class="n">b2</span><span class="p">,</span> <span class="n">list_range</span><span class="o">=</span><span class="n">list_range</span><span class="p">,</span>
                        <span class="n">print_out</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">name_label</span> <span class="o">=</span> <span class="p">(</span><span class="n">name_print</span> <span class="o">+</span> <span class="n">name_append</span> <span class="o">+</span> <span class="s1">&#39;-</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">-</span><span class="si">{2}</span><span class="s1">.</span><span class="si">{3}</span><span class="s1">&#39;</span>
                              <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl1</span><span class="p">)),</span>
                                        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl2</span><span class="p">)),</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ratio&#39;</span><span class="p">:</span>
                <span class="n">array_bm</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_segment</span><span class="o">.</span><span class="n">band_math_ratio</span><span class="p">(</span>
                        <span class="n">wl1</span><span class="o">=</span><span class="n">wl1</span><span class="p">,</span> <span class="n">wl2</span><span class="o">=</span><span class="n">wl2</span><span class="p">,</span> <span class="n">b1</span><span class="o">=</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="o">=</span><span class="n">b2</span><span class="p">,</span> <span class="n">list_range</span><span class="o">=</span><span class="n">list_range</span><span class="p">,</span>
                        <span class="n">print_out</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">name_label</span> <span class="o">=</span> <span class="p">(</span><span class="n">name_print</span> <span class="o">+</span> <span class="n">name_append</span> <span class="o">+</span> <span class="s1">&#39;-</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">-</span><span class="si">{2}</span><span class="s1">.</span><span class="si">{3}</span><span class="s1">&#39;</span>
                              <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl1</span><span class="p">)),</span>
                                        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl2</span><span class="p">)),</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;derivative&#39;</span><span class="p">:</span>
                <span class="n">array_bm</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_segment</span><span class="o">.</span><span class="n">band_math_derivative</span><span class="p">(</span>
                        <span class="n">wl1</span><span class="o">=</span><span class="n">wl1</span><span class="p">,</span> <span class="n">wl2</span><span class="o">=</span><span class="n">wl2</span><span class="p">,</span> <span class="n">wl3</span><span class="o">=</span><span class="n">wl3</span><span class="p">,</span> <span class="n">b1</span><span class="o">=</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="o">=</span><span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="o">=</span><span class="n">b3</span><span class="p">,</span>
                        <span class="n">list_range</span><span class="o">=</span><span class="n">list_range</span><span class="p">,</span> <span class="n">print_out</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">name_label</span> <span class="o">=</span> <span class="p">(</span><span class="n">name_print</span> <span class="o">+</span> <span class="n">name_append</span> <span class="o">+</span> <span class="s1">&#39;-</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">-</span><span class="si">{2}</span><span class="s1">-</span><span class="si">{3}</span><span class="s1">.</span><span class="si">{4}</span><span class="s1">&#39;</span>
                              <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl1</span><span class="p">)),</span>
                                        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl2</span><span class="p">)),</span>
                                        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl3</span><span class="p">)),</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mcari2&#39;</span><span class="p">:</span>
                <span class="n">array_bm</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_segment</span><span class="o">.</span><span class="n">band_math_mcari2</span><span class="p">(</span>
                        <span class="n">wl1</span><span class="o">=</span><span class="n">wl1</span><span class="p">,</span> <span class="n">wl2</span><span class="o">=</span><span class="n">wl2</span><span class="p">,</span> <span class="n">wl3</span><span class="o">=</span><span class="n">wl3</span><span class="p">,</span> <span class="n">b1</span><span class="o">=</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="o">=</span><span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="o">=</span><span class="n">b3</span><span class="p">,</span>
                        <span class="n">list_range</span><span class="o">=</span><span class="n">list_range</span><span class="p">,</span> <span class="n">print_out</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">name_label</span> <span class="o">=</span> <span class="p">(</span><span class="n">name_print</span> <span class="o">+</span> <span class="n">name_append</span> <span class="o">+</span> <span class="s1">&#39;-</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">-</span><span class="si">{2}</span><span class="s1">-</span><span class="si">{3}</span><span class="s1">.</span><span class="si">{4}</span><span class="s1">&#39;</span>
                              <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl1</span><span class="p">)),</span>
                                        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl2</span><span class="p">)),</span>
                                        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl3</span><span class="p">)),</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">))</span>

            <span class="n">stat_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array_bm</span><span class="p">))</span>
            <span class="n">stat_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">array_bm</span><span class="p">)</span>
            <span class="n">stat_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">array_bm</span><span class="p">)</span>
            <span class="n">stat_med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">array_bm</span><span class="p">)</span>
            <span class="n">stat_pctls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">array_bm</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">95</span><span class="p">])</span>

            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">fname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">name_plot</span><span class="p">,</span> <span class="n">stat_count</span><span class="p">,</span> <span class="n">stat_mean</span><span class="p">,</span> <span class="n">stat_std</span><span class="p">,</span>
                    <span class="n">stat_med</span><span class="p">,</span> <span class="n">stat_pctls</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stat_pctls</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stat_pctls</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="n">stat_pctls</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">stat_pctls</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">stat_pctls</span><span class="p">[</span><span class="mi">5</span><span class="p">]]</span>
            <span class="n">df_stats_temp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">data</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">df_stats</span> <span class="o">=</span> <span class="n">df_stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_stats_temp</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">plot_out</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">fname_fig</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span>
                                         <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">name_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                                         <span class="s1">&#39;.png&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">plot_histogram</span><span class="p">(</span>
                        <span class="n">array_bm</span><span class="p">,</span> <span class="n">fname_fig</span><span class="o">=</span><span class="n">fname_fig</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">name_print</span><span class="p">,</span>
                        <span class="n">xlabel</span><span class="o">=</span><span class="n">type_bm</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">percentile</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                        <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#444444&#39;</span><span class="p">)</span>
<span class="c1">#                self._plot_histogram(array_bm, fname_fig, title=name_print,</span>
<span class="c1">#                                     xlabel=type_bm.upper(), percentile=90,</span>
<span class="c1">#                                     fontsize=14,</span>
<span class="c1">#                                     color=&#39;#444444&#39;)</span>

            <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name_label</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_write_datacube</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span><span class="p">,</span> <span class="n">array_bm</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">geotiff</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_geotiff</span><span class="p">(</span><span class="n">array_bm</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span><span class="p">,</span>
                                    <span class="n">metadata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_segment</span><span class="o">.</span><span class="n">tools</span><span class="p">)</span>

        <span class="n">fname_stats</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="s1">&#39;-stats.csv&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fname_stats</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">force</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">df_stats_in</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fname_stats</span><span class="p">)</span>
            <span class="n">df_stats</span> <span class="o">=</span> <span class="n">df_stats_in</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_stats</span><span class="p">)</span>
        <span class="n">df_stats</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fname_stats</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_get_ndvi_simple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df_class_spec</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">,</span> <span class="n">plot_out</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Find kmeans class with lowest NDVI, which represents the soil class</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="n">nir_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="mi">760</span><span class="p">)</span>
            <span class="n">re_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="mi">715</span><span class="p">)</span>
            <span class="n">red_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="mi">681</span><span class="p">)</span>
            <span class="n">green_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="mi">555</span><span class="p">)</span>

            <span class="n">nir</span> <span class="o">=</span> <span class="n">df_class_spec</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">nir_b</span><span class="p">]</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">df_class_spec</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">re_b</span><span class="p">]</span>
            <span class="n">red</span> <span class="o">=</span> <span class="n">df_class_spec</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">red_b</span><span class="p">]</span>
            <span class="n">green</span> <span class="o">=</span> <span class="n">df_class_spec</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">green_b</span><span class="p">]</span>

            <span class="n">df_ndvi</span> <span class="o">=</span> <span class="p">(</span><span class="n">nir</span><span class="o">-</span><span class="n">red</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nir</span><span class="o">+</span><span class="n">red</span><span class="p">)</span>
            <span class="n">class_soil</span> <span class="o">=</span> <span class="n">df_ndvi</span><span class="p">[</span><span class="n">df_ndvi</span> <span class="o">==</span> <span class="n">df_ndvi</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">class_veg</span> <span class="o">=</span> <span class="n">df_ndvi</span><span class="p">[</span><span class="n">df_ndvi</span> <span class="o">==</span> <span class="n">df_ndvi</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">plot_out</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">df_class_spec</span><span class="p">[</span><span class="s1">&#39;wavelength&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">meta_bands</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">df_class_spec</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
                <span class="n">legend</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">legend</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;K-means classes&#39;</span><span class="p">)</span>
                <span class="n">legend</span><span class="o">.</span><span class="n">texts</span><span class="p">[</span><span class="n">class_soil</span><span class="p">]</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;Soil&#39;</span><span class="p">)</span>
                <span class="n">legend</span><span class="o">.</span><span class="n">texts</span><span class="p">[</span><span class="n">class_veg</span><span class="p">]</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s1">&#39;Vegetation&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">class_soil</span><span class="p">,</span> <span class="n">class_veg</span>

    <span class="k">def</span> <span class="nf">_execute_kmeans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span>
                        <span class="n">name_append</span><span class="p">,</span> <span class="n">geotiff</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span>
                        <span class="n">plot_out</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Actually executes the kmeans clustering to keep the main function a bit</span>
<span class="sd">        cleaner</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_classes</span><span class="p">):</span>
            <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;class_</span><span class="si">{0}</span><span class="s1">_count&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_classes</span><span class="p">):</span>
            <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;class_</span><span class="si">{0}</span><span class="s1">_ndvi&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_classes</span><span class="p">):</span>
            <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;class_</span><span class="si">{0}</span><span class="s1">_gndvi&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_classes</span><span class="p">):</span>
            <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;class_</span><span class="si">{0}</span><span class="s1">_ndre&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_classes</span><span class="p">):</span>
            <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;class_</span><span class="si">{0}</span><span class="s1">_mcari2&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">df_stats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fname_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_cube</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="o">.</span><span class="n">metadata</span>
            <span class="n">base_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">base_dir_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                        <span class="n">base_dir</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                        <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
            <span class="n">name_print</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_name_print</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">my_segment</span> <span class="o">=</span> <span class="n">segment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="p">)</span>

            <span class="n">array_class</span><span class="p">,</span> <span class="n">df_class_spec</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_segment</span><span class="o">.</span><span class="n">kmeans</span><span class="p">(</span>
                    <span class="n">n_classes</span><span class="o">=</span><span class="n">n_classes</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
                    <span class="n">spyfile</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">fname</span><span class="p">]</span>
            <span class="n">nir_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_segment</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="mi">800</span><span class="p">)</span>
            <span class="n">re_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_segment</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="mi">720</span><span class="p">)</span>
            <span class="n">red_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_segment</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="mi">670</span><span class="p">)</span>
            <span class="n">green_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_segment</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">get_band</span><span class="p">(</span><span class="mi">550</span><span class="p">)</span>
            <span class="n">nir</span> <span class="o">=</span> <span class="n">df_class_spec</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">nir_b</span><span class="p">]</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">df_class_spec</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">re_b</span><span class="p">]</span>
            <span class="n">red</span> <span class="o">=</span> <span class="n">df_class_spec</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">red_b</span><span class="p">]</span>
            <span class="n">green</span> <span class="o">=</span> <span class="n">df_class_spec</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">green_b</span><span class="p">]</span>
            <span class="n">df_ndvi</span> <span class="o">=</span> <span class="p">(</span><span class="n">nir</span> <span class="o">-</span> <span class="n">red</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nir</span> <span class="o">+</span> <span class="n">red</span><span class="p">)</span>
            <span class="n">df_gndvi</span> <span class="o">=</span> <span class="p">(</span><span class="n">nir</span> <span class="o">-</span> <span class="n">green</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nir</span> <span class="o">+</span> <span class="n">green</span><span class="p">)</span>
            <span class="n">df_ndre</span> <span class="o">=</span> <span class="p">(</span><span class="n">nir</span> <span class="o">-</span> <span class="n">re</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nir</span> <span class="o">+</span> <span class="n">re</span><span class="p">)</span>
            <span class="n">df_mcari2</span> <span class="o">=</span> <span class="p">((</span><span class="mf">1.5</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">nir</span> <span class="o">-</span> <span class="n">red</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.3</span> <span class="o">*</span> <span class="p">(</span><span class="n">nir</span> <span class="o">-</span> <span class="n">green</span><span class="p">)))</span> <span class="o">/</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">nir</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">nir</span> <span class="o">-</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">red</span><span class="p">))</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_classes</span><span class="p">):</span>
                <span class="n">class_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_class</span><span class="p">[</span><span class="n">array_class</span> <span class="o">==</span> <span class="n">i</span><span class="p">])</span>
                <span class="n">pix_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_class</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">class_n</span> <span class="o">/</span> <span class="n">pix_n</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">:</span>  <span class="c1"># if &lt; 5% of pixels in a class</span>
                    <span class="n">df_ndvi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">df_gndvi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">df_ndre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="n">df_mcari2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array_class</span><span class="p">[</span><span class="n">array_class</span> <span class="o">==</span> <span class="n">i</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">ndvi</span> <span class="ow">in</span> <span class="n">df_ndvi</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ndvi</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">gndvi</span> <span class="ow">in</span> <span class="n">df_gndvi</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gndvi</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ndre</span> <span class="ow">in</span> <span class="n">df_ndre</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ndre</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">mcari2</span> <span class="ow">in</span> <span class="n">df_mcari2</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mcari2</span><span class="p">)</span>

            <span class="n">df_stats_temp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">data</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">df_stats</span> <span class="o">=</span> <span class="n">df_stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_stats_temp</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">name_label</span> <span class="o">=</span> <span class="p">(</span><span class="n">name_print</span> <span class="o">+</span> <span class="n">name_append</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">plot_out</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">df_class_spec</span><span class="p">[</span><span class="s1">&#39;wavelength&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">meta_bands</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
                <span class="n">df_class_spec</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;wavelength&#39;</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">sns</span><span class="o">.</span><span class="n">lineplot</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">df_class_spec</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">name_label</span><span class="p">))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Wavelength&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Reflectance (%)&#39;</span><span class="p">)</span>
                <span class="n">legend</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">legend</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;K-means classes&#39;</span><span class="p">)</span>
<span class="c1">#                legend.texts[class_soil].set_text(&#39;Soil&#39;)</span>
<span class="c1">#                legend.texts[class_veg].set_text(&#39;Vegetation&#39;)</span>
                <span class="n">fname_fig</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">name_print</span> <span class="o">+</span> <span class="n">name_append</span> <span class="o">+</span>
                                         <span class="s1">&#39;.png&#39;</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname_fig</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_write_datacube</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span><span class="p">,</span> <span class="n">array_class</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>

<span class="c1">#            name_label_spec = (os.path.splitext(name_label)[0] +</span>
<span class="c1">#                                       &#39;-spec-mean.spec&#39;)</span>
<span class="c1">#            self._write_spec(dir_out, name_label, spec_mean, spec_std,</span>
<span class="c1">#                            metadata)</span>
            <span class="k">if</span> <span class="n">geotiff</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_geotiff</span><span class="p">(</span><span class="n">array_class</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span><span class="p">,</span>
                                    <span class="n">metadata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_segment</span><span class="o">.</span><span class="n">tools</span><span class="p">)</span>

<span class="c1">#            if mask_soil is True:</span>
<span class="c1">#                class_soil, class_veg = self._get_ndvi_simple(</span>
<span class="c1">#                        df_class_spec, n_classes, plot_out=True)</span>
<span class="c1">#                array_class = np.ma.masked_where(array_class==class_soil,</span>
<span class="c1">#                                                 array_class)</span>
<span class="c1">#                name_label = (name_print + name_append + &#39;-mask-soil&#39; + &#39;.&#39; +</span>
<span class="c1">#                              self.io.defaults.envi_write.interleave)</span>
<span class="c1">#                self._write_datacube(dir_out, name_label, array_class,</span>
<span class="c1">#                                     metadata)</span>

        <span class="n">fname_stats</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="s1">&#39;-stats.csv&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fname_stats</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">force</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">df_stats_in</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fname_stats</span><span class="p">)</span>
            <span class="n">df_stats</span> <span class="o">=</span> <span class="n">df_stats_in</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_stats</span><span class="p">)</span>
        <span class="n">df_stats</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fname_stats</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_crop_check_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_sheet</span><span class="p">,</span> <span class="n">fname_list</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Checks that either `fname_sheet` or `fname_list` were passed (and not</span>
<span class="sd">        both)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">fname_sheet</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname_sheet</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">fname_list</span><span class="p">):</span>
                <span class="n">df_plots</span> <span class="o">=</span> <span class="n">fname_sheet</span>
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fname_sheet</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.csv&#39;</span> <span class="ow">and</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">fname_list</span><span class="p">):</span>
                <span class="n">df_plots</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fname_sheet</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg2</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Both ``fname_sheet`` and ``fname_list`` were passed. &#39;</span>
                        <span class="s1">&#39;``fname_list`` (perhaps from ``base_dir``) will be &#39;</span>
                        <span class="s1">&#39;ignored.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">msg2</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname_sheet</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="n">df_plots</span> <span class="o">=</span> <span class="n">fname_sheet</span>
                <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fname_sheet</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.csv&#39;</span><span class="p">:</span>
                    <span class="n">df_plots</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fname_sheet</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">df_plots</span>
        <span class="k">elif</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">fname_sheet</span><span class="p">)</span> <span class="ow">and</span> <span class="n">pd</span><span class="o">.</span><span class="n">isnull</span><span class="p">(</span><span class="n">fname_list</span><span class="p">):</span>
            <span class="n">msg1</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Neither ``fname_sheet`` nor ``fname_list`` were passed. &#39;</span>
                    <span class="s1">&#39;Please pass one or the other (not both) and run &#39;</span>
                    <span class="s1">&#39;``batch.spatial_crop`` again.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg1</span><span class="p">)</span>
<span class="c1">#        elif fname_sheet is not None and fname_list is not None:</span>
<span class="c1">#            msg2 = (&#39;Both ``fname_sheet`` and ``fname_list`` were passed. &#39;</span>
<span class="c1">#                    &#39;``fname_list`` (perhaps from ``base_dir``) will be &#39;</span>
<span class="c1">#                    &#39;ignored.\n&#39;)</span>
<span class="c1">#            print(msg2)</span>
<span class="c1">#            if isinstance(fname_sheet, pd.DataFrame):</span>
<span class="c1">#                df_plots = fname_sheet</span>
<span class="c1">#            elif os.path.splitext(fname_sheet)[-1] == &#39;.csv&#39;:</span>
<span class="c1">#                df_plots = pd.read_csv(fname_sheet)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># fname_list was passed and df_plots will be figured out later</span>
            <span class="n">msg3</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;``method`` is &quot;single&quot;, but ``fname_list`` was passed &#39;</span>
                    <span class="s1">&#39;instead of ``fname_sheet``.</span><span class="se">\n\n</span><span class="s1">If performing &#39;</span>
                    <span class="s1">&#39;``crop_single``, please pass ``fname_sheet``.</span><span class="se">\n\n</span><span class="s1">If &#39;</span>
                    <span class="s1">&#39;performing ``crop_many_gdf``, please pass ``fname_list`` &#39;</span>
                    <span class="s1">&#39;(perhaps via ``base_dir``).</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;many_grid&#39;</span><span class="p">,</span> <span class="s1">&#39;many_gdf&#39;</span><span class="p">],</span> <span class="n">msg3</span>
            <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_crop_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df_plots</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span>
                   <span class="n">name_append</span><span class="p">,</span> <span class="n">geotiff</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        ``df_plots`` is assumed to contain all the necessary information to</span>
<span class="sd">        crop *each plot* from an image or from multiple images. In other words,</span>
<span class="sd">        _crop_loop() will perform a single cropping procedure (via</span>
<span class="sd">        ``spatial_mod.crop_single()``) for each row in ``df_plots``. Thus,</span>
<span class="sd">        all the necessary information should be contained in df_plots to run</span>
<span class="sd">        crop_single(). This function is not meant for dataframes containing</span>
<span class="sd">        information to perform crop_many(), so be sure to hone in on that</span>
<span class="sd">        information before passing ``_crop_loop``.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_plots</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crop_read_sheet</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;directory&#39;</span><span class="p">],</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Spatially cropping: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
            <span class="n">name_long</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;name_long&#39;</span><span class="p">]</span>  <span class="c1"># ``None`` if it was never set</span>
            <span class="n">plot_id</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;plot_id&#39;</span><span class="p">]</span>
            <span class="n">name_short</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;name_short&#39;</span><span class="p">]</span>
            <span class="n">fname_hdr</span> <span class="o">=</span> <span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;.hdr&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_cube</span><span class="p">(</span><span class="n">fname_hdr</span><span class="p">,</span> <span class="n">name_long</span><span class="o">=</span><span class="n">name_long</span><span class="p">,</span>
                              <span class="n">name_plot</span><span class="o">=</span><span class="n">plot_id</span><span class="p">,</span> <span class="n">name_short</span><span class="o">=</span><span class="n">name_short</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">my_spatial_mod</span> <span class="o">=</span> <span class="n">spatial_mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="p">,</span> <span class="n">gdf</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">my_spatial_mod</span><span class="o">.</span><span class="n">defaults</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span>
            <span class="k">if</span> <span class="n">base_dir_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                        <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;directory&#39;</span><span class="p">],</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                        <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
            <span class="n">name_print</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_name_print</span><span class="p">()</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pix_to_mapunit</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
<span class="c1">#            if method == &#39;single&#39;:</span>
            <span class="n">array_crop</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_spatial_mod</span><span class="o">.</span><span class="n">crop_single</span><span class="p">(</span>
                    <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;pix_e_ul&#39;</span><span class="p">],</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;pix_n_ul&#39;</span><span class="p">],</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_e_pix&#39;</span><span class="p">],</span>
                    <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_n_pix&#39;</span><span class="p">],</span> <span class="n">buf_e_pix</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_e_pix&#39;</span><span class="p">],</span>
                    <span class="n">buf_n_pix</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_n_pix&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;plot_id&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name_plot</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;plot_id&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name_plot</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">name_label</span> <span class="o">=</span> <span class="p">(</span><span class="n">name_print</span> <span class="o">+</span> <span class="n">name_plot</span> <span class="o">+</span> <span class="n">name_append</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">)</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;directory&#39;</span><span class="p">],</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_datacube</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span><span class="p">,</span> <span class="n">array_crop</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">geotiff</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_geotiff</span><span class="p">(</span><span class="n">array_crop</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span><span class="p">,</span>
                                    <span class="n">metadata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_spatial_mod</span><span class="o">.</span><span class="n">tools</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_crop_many_read_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Helper function for reading a row of a dataframe with information about</span>
<span class="sd">        how to crop an image many times</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crop_read_sheet</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>  <span class="c1"># this function creates cs[&#39;fname&#39;]</span>
        <span class="n">fname_in</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;directory&#39;</span><span class="p">],</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Filename: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname_in</span><span class="p">))</span>
        <span class="n">name_long</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;name_long&#39;</span><span class="p">]</span>  <span class="c1"># ``None`` if it was never set</span>
        <span class="n">plot_id</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;plot_id&#39;</span><span class="p">]</span>
        <span class="n">name_short</span> <span class="o">=</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;name_short&#39;</span><span class="p">]</span>
        <span class="n">fname_hdr</span> <span class="o">=</span> <span class="n">fname_in</span> <span class="o">+</span> <span class="s1">&#39;.hdr&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_cube</span><span class="p">(</span><span class="n">fname_hdr</span><span class="p">,</span> <span class="n">name_long</span><span class="o">=</span><span class="n">name_long</span><span class="p">,</span>
                          <span class="n">name_plot</span><span class="o">=</span><span class="n">plot_id</span><span class="p">,</span> <span class="n">name_short</span><span class="o">=</span><span class="n">name_short</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">my_spatial_mod</span> <span class="o">=</span> <span class="n">spatial_mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="p">,</span> <span class="n">gdf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">my_spatial_mod</span><span class="o">.</span><span class="n">defaults</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;many_gdf&#39;</span><span class="p">:</span>
            <span class="n">df_plots_many</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_many_gdf</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;many_grid&#39;</span><span class="p">:</span>
            <span class="n">df_plots_many</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_many_grid</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;``method`` must be either &quot;many_gdf&quot; or &quot;many_grid&quot;.</span><span class="se">\n</span><span class="s1">&#39;</span>
                   <span class="s1">&#39;Method: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df_plots_many</span>

    <span class="k">def</span> <span class="nf">_many_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Wrapper to get consice access to ``spatial_mod.crop_many_grid()&#39;&#39;&#39;</span>
        <span class="n">df_plots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_spatial_mod</span><span class="o">.</span><span class="n">crop_many_grid</span><span class="p">(</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;plot_id&#39;</span><span class="p">],</span> <span class="n">pix_e_ul</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;pix_e_ul&#39;</span><span class="p">],</span> <span class="n">pix_n_ul</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;pix_n_ul&#39;</span><span class="p">],</span>
            <span class="n">crop_e_m</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_e_m&#39;</span><span class="p">],</span> <span class="n">crop_n_m</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_n_m&#39;</span><span class="p">],</span>
            <span class="n">alley_size_n_m</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;alley_size_n_m&#39;</span><span class="p">],</span> <span class="n">buf_e_m</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_e_m&#39;</span><span class="p">],</span>
            <span class="n">buf_n_m</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_n_m&#39;</span><span class="p">],</span> <span class="n">n_plots_x</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;n_plots_x&#39;</span><span class="p">],</span>
            <span class="n">n_plots_y</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;n_plots_y&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">df_plots</span>

    <span class="k">def</span> <span class="nf">_many_gdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Wrapper to get consice access to ``spatial_mod.crop_many_gdf();</span>
<span class="sd">        ``my_spatial_mod`` already has access to ``spyfile`` and ``gdf``, so no</span>
<span class="sd">        need to pass them here.</span>

<span class="sd">        If the buffer settings are None, but there are default settings for</span>
<span class="sd">        them, they are passed here</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;plot_id&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;plot_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">crop_defaults</span><span class="o">.</span><span class="n">plot_id</span>
        <span class="k">if</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_e_m&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_e_m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">crop_defaults</span><span class="o">.</span><span class="n">buf_e_m</span>
        <span class="k">if</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_n_m&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_n_m&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">crop_defaults</span><span class="o">.</span><span class="n">buf_n_m</span>
        <span class="k">if</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_e_pix&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_e_pix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">crop_defaults</span><span class="o">.</span><span class="n">buf_e_pix</span>
        <span class="k">if</span> <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_n_pix&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_n_pix&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">crop_defaults</span><span class="o">.</span><span class="n">buf_n_pix</span>

        <span class="n">df_plots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_spatial_mod</span><span class="o">.</span><span class="n">crop_many_gdf</span><span class="p">(</span>
            <span class="n">cs</span><span class="p">[</span><span class="s1">&#39;plot_id&#39;</span><span class="p">],</span> <span class="n">pix_e_ul</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;pix_e_ul&#39;</span><span class="p">],</span> <span class="n">pix_n_ul</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;pix_n_ul&#39;</span><span class="p">],</span>
            <span class="n">crop_e_m</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_e_m&#39;</span><span class="p">],</span> <span class="n">crop_n_m</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;crop_n_m&#39;</span><span class="p">],</span>
            <span class="n">buf_e_m</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_e_m&#39;</span><span class="p">],</span> <span class="n">buf_n_m</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;buf_n_m&#39;</span><span class="p">],</span>
            <span class="n">n_plots</span><span class="o">=</span><span class="n">cs</span><span class="p">[</span><span class="s1">&#39;n_plots&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">df_plots</span>

    <span class="k">def</span> <span class="nf">_crop_execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_sheet</span><span class="p">,</span> <span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span>
                      <span class="n">name_append</span><span class="p">,</span> <span class="n">geotiff</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">gdf</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Actually executes the spatial crop to keep the main function a bit</span>
<span class="sd">        cleaner</span>

<span class="sd">        Either `fname_sheet` or `fname_list` should be None</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">df_plots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crop_check_input</span><span class="p">(</span><span class="n">fname_sheet</span><span class="p">,</span> <span class="n">fname_list</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_crop_loop</span><span class="p">(</span><span class="n">df_plots</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;many_gdf&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df_plots</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="c1"># if user passes a dataframe, just do whatever it says..</span>
            <span class="c1"># loop through each row, doing crop_many_gdf() on each row with</span>
            <span class="c1"># whatever parameters are passed via the columns..</span>
            <span class="c1"># we should assume that each row of df_plots contains an image that</span>
            <span class="c1"># should have crop_many_gdf performed on it to create a new</span>
            <span class="c1"># dataframe that can be passed to _crop_loop()</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_plots</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Computing information to spatially crop via &#39;</span>
                      <span class="s1">&#39;``spatial_mod.crop_many_gdf``:&#39;</span><span class="p">)</span>
                <span class="n">df_plots_many</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crop_many_read_row</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_crop_loop</span><span class="p">(</span><span class="n">df_plots_many</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span>
                                <span class="n">name_append</span><span class="p">,</span> <span class="n">geotiff</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;many_gdf&#39;</span> <span class="ow">and</span> <span class="n">df_plots</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fname_in</span> <span class="ow">in</span> <span class="n">fname_list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_cube</span><span class="p">(</span><span class="n">fname_in</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">my_spatial_mod</span> <span class="o">=</span> <span class="n">spatial_mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="p">,</span> <span class="n">gdf</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">my_spatial_mod</span><span class="o">.</span><span class="n">defaults</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span>
                <span class="n">df_plots_many</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_spatial_mod</span><span class="o">.</span><span class="n">crop_many_gdf</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_crop_loop</span><span class="p">(</span><span class="n">df_plots_many</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span>
                                <span class="n">name_append</span><span class="p">,</span> <span class="n">geotiff</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;many_grid&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df_plots</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_plots</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Computing information to spatially crop via &#39;</span>
                      <span class="s1">&#39;``spatial_mod.crop_many_grid``:&#39;</span><span class="p">)</span>
                <span class="n">df_plots_many</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_crop_many_read_row</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_crop_loop</span><span class="p">(</span><span class="n">df_plots_many</span><span class="p">,</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span>
                                <span class="n">name_append</span><span class="p">,</span> <span class="n">geotiff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Either ``method`` or ``df_plots`` are not defined &#39;</span>
                   <span class="s1">&#39;correctly. If using &quot;many_grid&quot; method, please be sure &#39;</span>
                   <span class="s1">&#39;``df_plots`` is being populated correcty</span><span class="se">\n\n</span><span class="s1">``method``: &#39;</span>
                   <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

<span class="c1">#        for idx, row in df_plots.iterrows():</span>
<span class="c1">#            cs = self._crop_read_sheet(row)</span>
<span class="c1">#            fname = os.path.join(cs[&#39;directory&#39;], cs[&#39;fname&#39;])</span>
<span class="c1">#            print(&#39;\nSpatially cropping: {0}&#39;.format(fname))</span>
<span class="c1">#            name_long = cs[&#39;name_long&#39;]  # ``None`` if it was never set</span>
<span class="c1">#            plot_id = cs[&#39;plot_id&#39;]</span>
<span class="c1">#            name_short = cs[&#39;name_short&#39;]</span>
<span class="c1">#            fname_hdr = fname + &#39;.hdr&#39;</span>
<span class="c1">#            self.io.read_cube(fname_hdr, name_long=name_long,</span>
<span class="c1">#                              name_plot=plot_id, name_short=name_short)</span>
<span class="c1">#            cs = self._pix_to_mapunit(cs)</span>
<span class="c1">#            self.my_spatial_mod = spatial_mod(self.io.spyfile, gdf)</span>
<span class="c1">#            if base_dir_out is None:</span>
<span class="c1">#                dir_out, name_append = self._save_file_setup(</span>
<span class="c1">#                        cs[&#39;directory&#39;], folder_name, name_append)</span>
<span class="c1">#            else:</span>
<span class="c1">#                dir_out, name_append = self._save_file_setup(</span>
<span class="c1">#                        base_dir_out, folder_name, name_append)</span>
<span class="c1">#            name_print = self._get_name_print()</span>
<span class="c1">##            if method == &#39;single&#39;:</span>
<span class="c1">#            array_crop, metadata = self.my_spatial_mod.crop_single(</span>
<span class="c1">#                    cs[&#39;pix_e_ul&#39;], cs[&#39;pix_n_ul&#39;], cs[&#39;crop_e_pix&#39;],</span>
<span class="c1">#                    cs[&#39;crop_n_pix&#39;], buf_e_pix=cs[&#39;buf_e_pix&#39;],</span>
<span class="c1">#                    buf_n_pix=cs[&#39;buf_n_pix&#39;])</span>
<span class="c1">#            if row[&#39;plot_id&#39;] is not None:</span>
<span class="c1">#                name_plot = &#39;_&#39; + str(row[&#39;plot_id&#39;])</span>
<span class="c1">#            else:</span>
<span class="c1">#                name_plot = &#39;&#39;</span>
<span class="c1">#            name_label = (name_print + name_plot + name_append + &#39;.&#39; +</span>
<span class="c1">#                          self.io.defaults.envi_write.interleave)</span>
<span class="c1">#            fname = os.path.join(cs[&#39;directory&#39;], cs[&#39;fname&#39;])</span>
<span class="c1">#            self._write_datacube(dir_out, name_label, array_crop, metadata)</span>
<span class="c1">#            if geotiff is True:</span>
<span class="c1">#                self._write_geotiff(array_crop, fname, dir_out, name_label,</span>
<span class="c1">#                                    metadata, self.my_spatial_mod.tools)</span>
<span class="c1">#            else:</span>
<span class="c1">#                if method == &#39;many_grid&#39;:</span>
<span class="c1">#                    df_plots = self._many_grid(cs)</span>
<span class="c1">#                elif method == &#39;many_gdf&#39;:</span>
<span class="c1">#                    df_plots = self._many_gdf(cs)</span>
<span class="c1">#</span>
<span class="c1">#                for idx, row in df_plots.iterrows():  # actually crop the image</span>
<span class="c1">#                    # reload spyfile to my_spatial_mod??</span>
<span class="c1">#                    self.io.read_cube(fname_hdr, name_long=name_long,</span>
<span class="c1">#                                      name_plot=plot_id, name_short=name_short)</span>
<span class="c1">#                    self.my_spatial_mod.load_spyfile(self.io.spyfile)</span>
<span class="c1">#                    crop_e_pix = cs[&#39;crop_e_pix&#39;]</span>
<span class="c1">#                    crop_n_pix = cs[&#39;crop_n_pix&#39;]</span>
<span class="c1">#                    if pd.isnull(crop_e_pix):</span>
<span class="c1">#                        crop_e_pix = row[&#39;crop_e_pix&#39;]</span>
<span class="c1">#                    if pd.isnull(crop_n_pix):</span>
<span class="c1">#                        crop_n_pix = row[&#39;crop_n_pix&#39;]</span>
<span class="c1">#</span>
<span class="c1">#                    array_crop, metadata = self.my_spatial_mod.crop_single(</span>
<span class="c1">#                        row[&#39;pix_e_ul&#39;], row[&#39;pix_n_ul&#39;],</span>
<span class="c1">#                        crop_e_pix=crop_e_pix,</span>
<span class="c1">#                        crop_n_pix=crop_n_pix,</span>
<span class="c1">#                        buf_e_pix=cs[&#39;buf_e_pix&#39;],</span>
<span class="c1">#                        buf_n_pix=cs[&#39;buf_n_pix&#39;],</span>
<span class="c1">#                        plot_id=row[&#39;plot_id&#39;], gdf=gdf)</span>
<span class="c1">##                    metadata = row[&#39;metadata&#39;]</span>
<span class="c1">##                    array_crop = row[&#39;array_crop&#39;]</span>
<span class="c1">#                    if row[&#39;plot_id&#39;] is not None:</span>
<span class="c1">#                        name_plot = &#39;_&#39; + str(row[&#39;plot_id&#39;])</span>
<span class="c1">#                    else:</span>
<span class="c1">#                        name_plot = &#39;&#39;</span>
<span class="c1">#                    name_label = (name_print + name_plot + name_append + &#39;.&#39; +</span>
<span class="c1">#                                  self.io.defaults.envi_write.interleave)</span>
<span class="c1">#                    fname = os.path.join(cs[&#39;directory&#39;], cs[&#39;fname&#39;])</span>
<span class="c1">#                    self._write_datacube(dir_out, name_label, array_crop,</span>
<span class="c1">#                                         metadata)</span>
<span class="c1">#                    if geotiff is True:</span>
<span class="c1">#                        self._write_geotiff(array_crop, fname, dir_out,</span>
<span class="c1">#                                            name_label, metadata,</span>
<span class="c1">#                                            self.my_spatial_mod.tools)</span>
<span class="c1">#                self.metadata = metadata</span>

    <span class="k">def</span> <span class="nf">_write_datacube</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Writes a datacube to file using ``hsio.write_cube()``</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name_label</span>
        <span class="n">hdr_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span> <span class="o">+</span> <span class="s1">&#39;.hdr&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">write_cube</span><span class="p">(</span><span class="n">hdr_file</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                           <span class="n">force</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">force</span><span class="p">,</span>
                           <span class="n">ext</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">ext</span><span class="p">,</span>
                           <span class="n">interleave</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">,</span>
                           <span class="n">byteorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">byteorder</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_write_geotiff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span>
                       <span class="n">tools</span><span class="p">):</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name_label</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Projection and Geotransform information are required for &#39;</span>
               <span class="s1">&#39;writing the geotiff. This comes from the input filename, &#39;</span>
               <span class="s1">&#39;so please be sure the correct filename is passed to &#39;</span>
               <span class="s1">&#39;``fname``.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">fname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fname</span><span class="p">),</span> <span class="n">msg</span>
        <span class="n">fname_tif</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span>
                                 <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">name_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.tif&#39;</span><span class="p">)</span>
        <span class="n">img_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">_read_envi_gdal</span><span class="p">(</span><span class="n">fname_in</span><span class="o">=</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">projection_out</span> <span class="o">=</span> <span class="n">img_ds</span><span class="o">.</span><span class="n">GetProjection</span><span class="p">()</span>
<span class="c1">#            geotransform_out = img_ds.GetGeotransform()</span>
        <span class="n">img_ds</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># I only want to use GDAL when I have to..</span>

        <span class="n">map_set</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;map info&#39;</span><span class="p">]</span>
        <span class="n">ul_x_utm</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_meta_set</span><span class="p">(</span><span class="n">map_set</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">ul_y_utm</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_meta_set</span><span class="p">(</span><span class="n">map_set</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">size_x_m</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_meta_set</span><span class="p">(</span><span class="n">map_set</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">size_y_m</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">get_meta_set</span><span class="p">(</span><span class="n">map_set</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
        <span class="c1"># Note the last pixel size must be negative to begin at upper left</span>
        <span class="n">geotransform_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">ul_x_utm</span><span class="p">,</span> <span class="n">size_x_m</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">ul_y_utm</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                            <span class="o">-</span><span class="n">size_y_m</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">write_tif</span><span class="p">(</span><span class="n">fname_tif</span><span class="p">,</span> <span class="n">spyfile</span><span class="o">=</span><span class="n">array</span><span class="p">,</span>
                          <span class="n">projection_out</span><span class="o">=</span><span class="n">projection_out</span><span class="p">,</span>
                          <span class="n">geotransform_out</span><span class="o">=</span><span class="n">geotransform_out</span><span class="p">,</span>
                          <span class="n">show_img</span><span class="o">=</span><span class="s1">&#39;inline&#39;</span><span class="p">)</span>
<span class="c1">#            if method == &#39;spatial&#39;:</span>
<span class="c1">#                ul_x_utm = self.my_spatial_mod.tools.get_meta_set(map_set, 3)</span>
<span class="c1">#                ul_y_utm = self.my_spatial_mod.tools.get_meta_set(map_set, 4)</span>
<span class="c1">#                size_x_m = self.my_spatial_mod.tools.get_meta_set(map_set, 5)</span>
<span class="c1">#                size_y_m = self.my_spatial_mod.tools.get_meta_set(map_set, 6)</span>
<span class="c1">#            if method == &#39;segment&#39;:</span>
<span class="c1">#                ul_x_utm = self.my_segment.tools.get_meta_set(map_set, 3)</span>
<span class="c1">#                ul_y_utm = self.my_segment.tools.get_meta_set(map_set, 4)</span>
<span class="c1">#                size_x_m = self.my_segment.tools.get_meta_set(map_set, 5)</span>
<span class="c1">#                size_y_m = self.my_segment.tools.get_meta_set(map_set, 6)</span>
<span class="c1">#            if method == &#39;spectral&#39;:</span>
<span class="c1">#                ul_x_utm = self.my_spectral_mod.tools.get_meta_set(map_set, 3)</span>
<span class="c1">#                ul_y_utm = self.my_spectral_mod.tools.get_meta_set(map_set, 4)</span>
<span class="c1">#                size_x_m = self.my_spectral_mod.tools.get_meta_set(map_set, 5)</span>
<span class="c1">#                size_y_m = self.my_spectral_mod.tools.get_meta_set(map_set, 6)</span>

    <span class="k">def</span> <span class="nf">_write_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span><span class="p">,</span> <span class="n">spec_mean</span><span class="p">,</span> <span class="n">spec_std</span><span class="p">,</span>
                    <span class="n">metadata</span><span class="p">):</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name_label</span>
        <span class="n">hdr_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span> <span class="o">+</span> <span class="s1">&#39;.hdr&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">write_spec</span><span class="p">(</span><span class="n">hdr_file</span><span class="p">,</span> <span class="n">spec_mean</span><span class="p">,</span> <span class="n">spec_std</span><span class="p">,</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                           <span class="n">force</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">force</span><span class="p">,</span>
                           <span class="n">ext</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">ext</span><span class="p">,</span>
                           <span class="n">interleave</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">,</span>
                           <span class="n">byteorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">byteorder</span><span class="p">,</span>
                           <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_execute_spec_clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span>
                           <span class="n">name_append</span><span class="p">,</span> <span class="n">wl_bands</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Actually executes the spectral clip to keep the main function a bit</span>
<span class="sd">        cleaner</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fname_list</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Spectrally clipping: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
            <span class="c1"># options for io.read_cube():</span>
            <span class="c1"># name_long, name_plot, name_short, individual_plot, overwrite</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_cube</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">my_spectral_mod</span> <span class="o">=</span> <span class="n">spec_mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="p">)</span>
            <span class="n">base_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">base_dir_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                        <span class="n">base_dir</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                        <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
            <span class="n">name_print</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_name_print</span><span class="p">()</span>
            <span class="n">array_clip</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_spectral_mod</span><span class="o">.</span><span class="n">spectral_clip</span><span class="p">(</span>
                    <span class="n">wl_bands</span><span class="o">=</span><span class="n">wl_bands</span><span class="p">)</span>

            <span class="n">name_label</span> <span class="o">=</span> <span class="p">(</span><span class="n">name_print</span> <span class="o">+</span> <span class="n">name_append</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">)</span>
            <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name_label</span>

            <span class="n">hdr_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span> <span class="o">+</span> <span class="s1">&#39;.hdr&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">write_cube</span><span class="p">(</span><span class="n">hdr_file</span><span class="p">,</span> <span class="n">array_clip</span><span class="p">,</span>
                               <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                               <span class="n">force</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">force</span><span class="p">,</span>
                               <span class="n">ext</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">ext</span><span class="p">,</span>
                               <span class="n">interleave</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">,</span>
                               <span class="n">byteorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">byteorder</span><span class="p">,</span>
                               <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_execute_spec_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Actually executes the spectra combine to keep the main function a bit</span>
<span class="sd">        cleaner</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">df_specs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">base_dir_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base_dir_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">fname_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">pix_n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fname_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_spec</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">spy_mem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile_spec</span><span class="o">.</span><span class="n">open_memmap</span><span class="p">()</span>
            <span class="n">pix_n</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">spy_mem</span><span class="p">))</span> <span class="o">/</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile_spec</span><span class="o">.</span><span class="n">nbands</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Combining datacubes/spectra into a single mean spectra.</span><span class="se">\n</span><span class="s1">&#39;</span>
              <span class="s1">&#39;Number of input datacubes/spectra: </span><span class="si">{0}</span><span class="se">\n</span><span class="s1">Total number of &#39;</span>
              <span class="s1">&#39;pixels: </span><span class="si">{1}</span><span class="s1">&#39;</span>
              <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fname_list</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">pix_n</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fname_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_spec</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile_spec</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">pixels</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                       <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pixels</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">df_specs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">df_specs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">df_temp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">df_specs</span> <span class="o">=</span> <span class="n">df_specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_temp</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">df_mean</span> <span class="o">=</span> <span class="n">df_specs</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_mean</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_std</span> <span class="o">=</span> <span class="n">df_specs</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df_std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_std</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;std&#39;</span><span class="p">)</span>
        <span class="n">df_cv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_mean</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_std</span>
        <span class="n">df_cv</span> <span class="o">=</span> <span class="n">df_cv</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;cv&#39;</span><span class="p">)</span>

        <span class="n">hdr_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_dir_out</span><span class="p">,</span> <span class="s1">&#39;spec_mean_spy.spec.hdr&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">write_spec</span><span class="p">(</span><span class="n">hdr_file</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_mean</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df_std</span><span class="p">,</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                           <span class="n">force</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">force</span><span class="p">,</span>
                           <span class="n">ext</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">ext</span><span class="p">,</span>
                           <span class="n">interleave</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">,</span>
                           <span class="n">byteorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">byteorder</span><span class="p">,</span>
                           <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile_spec</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_execute_spec_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span>
                             <span class="n">name_append</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">stats</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Actually executes the spectral smooth to keep the main function a bit</span>
<span class="sd">        cleaner</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">stats</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">df_smooth_stats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                    <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="s1">&#39;cv&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fname_list</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Spectrally smoothing: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_cube</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">my_spectral_mod</span> <span class="o">=</span> <span class="n">spec_mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="p">)</span>
            <span class="n">base_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">base_dir_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                        <span class="n">base_dir</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                        <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
            <span class="n">name_print</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_name_print</span><span class="p">()</span>
            <span class="n">array_smooth</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my_spectral_mod</span><span class="o">.</span><span class="n">spectral_smooth</span><span class="p">(</span>
                    <span class="n">window_size</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

            <span class="n">name_label</span> <span class="o">=</span> <span class="p">(</span><span class="n">name_print</span> <span class="o">+</span> <span class="n">name_append</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">)</span>
            <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name_label</span>

            <span class="n">hdr_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span> <span class="o">+</span> <span class="s1">&#39;.hdr&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">write_cube</span><span class="p">(</span><span class="n">hdr_file</span><span class="p">,</span> <span class="n">array_smooth</span><span class="p">,</span>
                               <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                               <span class="n">force</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">force</span><span class="p">,</span>
                               <span class="n">ext</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">ext</span><span class="p">,</span>
                               <span class="n">interleave</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">,</span>
                               <span class="n">byteorder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">byteorder</span><span class="p">,</span>
                               <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">stats</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">array_smooth</span><span class="p">)</span>
                <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">array_smooth</span><span class="p">)</span>
                <span class="n">cv</span> <span class="o">=</span> <span class="n">std</span><span class="o">/</span><span class="n">mean</span>
                <span class="n">df_smooth_temp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([[</span><span class="n">fname</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">cv</span><span class="p">]],</span>
                                              <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;fname&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">,</span>
                                                       <span class="s1">&#39;cv&#39;</span><span class="p">])</span>
                <span class="n">df_smooth_stats</span> <span class="o">=</span> <span class="n">df_smooth_stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_smooth_temp</span><span class="p">,</span>
                                                         <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stats</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">fname_stats</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="s1">&#39;-stats.csv&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fname_stats</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">force</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">df_stats_in</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">fname_stats</span><span class="p">)</span>
                <span class="n">df_smooth_stats</span> <span class="o">=</span> <span class="n">df_stats_in</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_smooth_stats</span><span class="p">)</span>
            <span class="n">df_smooth_stats</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fname_stats</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">df_smooth_stats</span>

    <span class="k">def</span> <span class="nf">_get_fname_similar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_to_match</span><span class="p">,</span> <span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="o">=</span><span class="s1">&#39;bip&#39;</span><span class="p">,</span>
                           <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Gets a similar filename from another directory</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="o">=</span><span class="n">search_ext</span><span class="p">,</span>
                                      <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="n">fname_similar</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fname_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name_to_match</span> <span class="ow">in</span> <span class="n">fname</span><span class="p">:</span>
                <span class="n">fname_similar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="n">msg1</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;No files found with a similar name to </span><span class="si">{0}</span><span class="s1">. Please be &#39;</span>
                <span class="s1">&#39;sure the images are created before continuing (e.g., did &#39;</span>
                <span class="s1">&#39;you perform band math yet?)</span><span class="se">\n\n</span><span class="s1">base_dir: </span><span class="si">{1}</span><span class="s1">&#39;</span>
                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name_to_match</span><span class="p">,</span> <span class="n">base_dir</span><span class="p">))</span>
        <span class="n">msg2</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Multiple files found with a similar name to </span><span class="si">{0}</span><span class="s1">. Please &#39;</span>
                <span class="s1">&#39;delete files that are not relevant to continue.</span><span class="se">\n\n</span><span class="s1">base_dir: &#39;</span>
                <span class="s1">&#39;</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name_to_match</span><span class="p">,</span> <span class="n">base_dir</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fname_similar</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">msg1</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fname_similar</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">msg2</span>
        <span class="k">return</span> <span class="n">fname_similar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_array_similar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dir_search</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Retrieves the array from a directory with a similar name to the loaded</span>
<span class="sd">        datacube (i.e., there must be a datacube loaded; self.io.spyfile should</span>
<span class="sd">        not be ``None``; compares to ``self.io.name_short``).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            dir_search: directory to search</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Please load a SpyFile prior to using this function&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">msg</span>
        <span class="n">fname_kmeans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_fname_similar</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">name_short</span><span class="p">,</span> <span class="n">dir_search</span><span class="p">,</span>
                <span class="n">search_ext</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">fpath_kmeans</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_search</span><span class="p">,</span> <span class="n">fname_kmeans</span><span class="p">)</span>
        <span class="n">io_mask</span> <span class="o">=</span> <span class="n">hsio</span><span class="p">()</span>
        <span class="n">io_mask</span><span class="o">.</span><span class="n">read_cube</span><span class="p">(</span><span class="n">fpath_kmeans</span><span class="p">)</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">io_mask</span><span class="o">.</span><span class="n">spyfile</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">io_mask</span><span class="o">.</span><span class="n">spyfile</span><span class="o">.</span><span class="n">metadata</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">,</span> <span class="n">metadata</span>

    <span class="k">def</span> <span class="nf">_get_class_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">filter_cols</span><span class="p">,</span> <span class="n">n_classes</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Finds the class with the lowest NDVI in ``row`` and returns the class ID</span>
<span class="sd">        to be used to dictate which pixels get masked</span>

<span class="sd">        Parameters:</span>
<span class="sd">            n_classes (``int``): number of classes to mask; if 1, then will mask</span>
<span class="sd">            the minimum ndvi; if more than 1, all classes (default: 1)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">row_ndvi</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">filter_cols</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">row_ndvi</span> <span class="o">=</span> <span class="n">row_ndvi</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">row_ndvi</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">n_classes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_ndvi</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_classes</span><span class="p">:</span>
            <span class="n">n_classes</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">row_ndvi_small</span> <span class="o">=</span> <span class="n">row_ndvi</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n_classes</span><span class="p">)</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="n">row_ndvi_small</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">class_mask</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">class_name</span><span class="p">:</span>
            <span class="n">class_int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
            <span class="n">class_mask</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">class_int</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">class_mask</span>

    <span class="k">def</span> <span class="nf">_recurs_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="o">=</span><span class="s1">&#39;.csv&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Searches all folders and subfolders recursively within &lt;base_dir&gt;</span>
<span class="sd">        for filetypes of &lt;search_exp&gt;.</span>
<span class="sd">        Returns sorted &lt;outFiles&gt;, a list of full path strings of each result.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            base_dir: directory path that should include files to be returned</span>
<span class="sd">            search_ext: file format/extension to search for in all directories</span>
<span class="sd">                and subdirectories</span>
<span class="sd">            level: how many levels to search; if None, searches all levels</span>

<span class="sd">        Returns:</span>
<span class="sd">            out_files: include the full pathname, filename, and ext of all</span>
<span class="sd">                files that have ``search_exp`` in their name.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">level</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">d_str</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">)</span>
        <span class="n">out_files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">d_str</span><span class="p">:</span>
            <span class="n">full_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">full_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">item</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">search_ext</span><span class="p">):</span>
                <span class="n">out_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">full_path</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">full_path</span><span class="p">)</span> <span class="ow">and</span> <span class="n">level</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_dir</span> <span class="o">=</span> <span class="n">full_path</span>  <span class="c1"># If dir, then search in that</span>
                <span class="n">out_files_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">new_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">out_files_temp</span><span class="p">:</span>  <span class="c1"># if list is not empty</span>
                    <span class="n">out_files</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">out_files_temp</span><span class="p">)</span>  <span class="c1"># add items</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">out_files</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_save_file_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Basic setup items when saving manipulated image files to disk</span>

<span class="sd">        Parameters:</span>
<span class="sd">            base_dir_out (``str``): Parent directory that all processed datacubes</span>
<span class="sd">                will be saved.</span>
<span class="sd">            folder_name (``str``): Folder to add to ``base_dir_out`` to save all</span>
<span class="sd">                the processed datacubes.</span>
<span class="sd">            name_append (``str``): name to append to the filename.</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="c1">#        if base_dir_out is None:</span>
<span class="c1">#            base_dir_out = os.path.join(self.base_dir, folder_name)</span>
        <span class="n">dir_out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">dir_out</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">dir_out</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name_append</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name_append</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name_append</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="n">name_append</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">name_append</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span>

    <span class="k">def</span> <span class="nf">_get_name_print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_in</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">name_print</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">name_short</span>
        <span class="k">if</span> <span class="n">name_print</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fname_in</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fname_in</span><span class="p">)</span>
            <span class="n">name_print</span> <span class="o">=</span> <span class="n">base_name</span><span class="p">[:</span><span class="n">base_name</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">base_name</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">))]</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Could not get a name for input datacube.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">name_print</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">msg</span>
        <span class="k">return</span> <span class="n">name_print</span>
<span class="c1">#</span>
<span class="c1">#    def _plot_histogram(self, array, fname_fig, title=None, xlabel=None,</span>
<span class="c1">#                        percentile=90, fontsize=16, color=&#39;#444444&#39;):</span>
<span class="c1">#        &#39;&#39;&#39;</span>
<span class="c1">#        Plots a histogram with the percentile value labeled</span>
<span class="c1">#        &#39;&#39;&#39;</span>
<span class="c1">#        if isinstance(array, np.ma.core.MaskedArray):</span>
<span class="c1">#            array_m = array.compressed()  # allows for accurate percentile calc</span>
<span class="c1">#        else:</span>
<span class="c1">#            array_m = np.ma.masked_array(array, mask=False)</span>
<span class="c1">#            array_m = array_m.compressed()</span>
<span class="c1">#</span>
<span class="c1">#        pctl = np.nanpercentile(array_m.flatten(), percentile)</span>
<span class="c1">#</span>
<span class="c1">#        fig, ax = plt.subplots()</span>
<span class="c1">#        ax = sns.distplot(array_m.flatten(), bins=50, color=&#39;grey&#39;)</span>
<span class="c1">#        data_x, data_y = ax.lines[0].get_data()</span>
<span class="c1">#</span>
<span class="c1">#        y_lim = ax.get_ylim()</span>
<span class="c1">#        yi = np.interp(pctl, data_x, data_y)</span>
<span class="c1">#        ymax = yi/y_lim[1]</span>
<span class="c1">#        ax.axvline(pctl, ymax=ymax, linestyle=&#39;--&#39;, color=color, linewidth=0.5)</span>
<span class="c1">#        boxstyle_str = &#39;round, pad=0.5, rounding_size=0.15&#39;</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#        legend_str = (&#39;Percentile ({0}): {1:.3f}&#39;</span>
<span class="c1">#                      &#39;&#39;.format(percentile, pctl))</span>
<span class="c1">#        ax.annotate(</span>
<span class="c1">#            legend_str,</span>
<span class="c1">#            xy=(pctl, yi),</span>
<span class="c1">#            xytext=(0.97, 0.94),  # loc to place text</span>
<span class="c1">#            textcoords=&#39;axes fraction&#39;,  # placed relative to axes</span>
<span class="c1">#            ha=&#39;right&#39;,  # alignment of text</span>
<span class="c1">#            va=&#39;top&#39;,</span>
<span class="c1">#            fontsize=int(fontsize * 0.9),</span>
<span class="c1">#            color=color,</span>
<span class="c1">#            bbox=dict(boxstyle=boxstyle_str, pad=0.5, fc=(1, 1, 1),</span>
<span class="c1">#                      ec=(0.5, 0.5, 0.5), alpha=0.5),</span>
<span class="c1">#            arrowprops=dict(arrowstyle=&#39;-|&gt;&#39;,</span>
<span class="c1">#                            color=color,</span>
<span class="c1">#        #                    patchB=el,</span>
<span class="c1">#                            shrinkA=0,</span>
<span class="c1">#                            shrinkB=0,</span>
<span class="c1">#                            connectionstyle=&#39;arc3,rad=-0.3&#39;,</span>
<span class="c1">#                            linestyle=&#39;--&#39;,</span>
<span class="c1">#                            linewidth=0.7))</span>
<span class="c1">#        ax.set_title(title, fontweight=&#39;bold&#39;, fontsize=int(fontsize * 1.1))</span>
<span class="c1">#        ax.set_xlabel(xlabel, fontsize=fontsize)</span>
<span class="c1">#        ax.set_ylabel(&#39;Frequency (%)&#39;, fontsize=fontsize)</span>
<span class="c1">#        ax.tick_params(labelsize=fontsize)</span>
<span class="c1">#        plt.tight_layout()</span>
<span class="c1">#        fig.savefig(fname_fig, dpi=300)</span>

<div class="viewcode-block" id="batch.cube_to_spectra"><a class="viewcode-back" href="../../api/hs_process.batch.html#hs_process.batch.cube_to_spectra">[docs]</a>    <span class="k">def</span> <span class="nf">cube_to_spectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">search_ext</span><span class="o">=</span><span class="s1">&#39;bip&#39;</span><span class="p">,</span>
                        <span class="n">dir_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">folder_name</span><span class="o">=</span><span class="s1">&#39;cube_to_spec&#39;</span><span class="p">,</span>
                        <span class="n">name_append</span><span class="o">=</span><span class="s1">&#39;cube-to-spec&#39;</span><span class="p">,</span>
                        <span class="n">geotiff</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">out_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_force</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">out_ext</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_interleave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">out_byteorder</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculates the mean and standard deviation for each cube in</span>
<span class="sd">        ``fname_list`` and writes the result to a &quot;.spec&quot; file.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            fname_list (``list``, optional): list of filenames to process; if</span>
<span class="sd">                left to ``None``, will look at ``base_dir``, ``search_ext``, and</span>
<span class="sd">                ``dir_level`` parameters for files to process (default: ``None``).</span>
<span class="sd">            base_dir (``str``, optional): directory path to search for files to</span>
<span class="sd">                spectrally clip; if ``fname_list`` is not ``None``, ``base_dir`` will</span>
<span class="sd">                be ignored (default: ``None``).</span>
<span class="sd">            search_ext (``str``): file format/extension to search for in all</span>
<span class="sd">                directories and subdirectories to determine which files to</span>
<span class="sd">                process; if ``fname_list`` is not ``None``, ``search_ext`` will</span>
<span class="sd">                be ignored (default: &#39;bip&#39;).</span>
<span class="sd">            dir_level (``int``): The number of directory levels to search; if</span>
<span class="sd">                ``None``, searches all directory levels (default: 0).</span>
<span class="sd">            base_dir_out (``str``): directory path to save all processed</span>
<span class="sd">                datacubes; if set to ``None``, a folder named according to the</span>
<span class="sd">                ``folder_name`` parameter is added to ``base_dir``</span>
<span class="sd">            folder_name (``str``): folder to add to ``base_dir_out`` to save all</span>
<span class="sd">                the processed datacubes (default: &#39;cube_to_spec&#39;).</span>
<span class="sd">            name_append (``str``): name to append to the filename (default:</span>
<span class="sd">                &#39;cube-to-spec&#39;).</span>
<span class="sd">            geotiff (``bool``): whether to save the masked RGB image as a geotiff</span>
<span class="sd">                alongside the masked datacube.</span>
<span class="sd">            out_XXX: Settings for saving the output files can be adjusted here</span>
<span class="sd">                if desired. They are stored in ``batch.io.defaults``, and are</span>
<span class="sd">                therefore accessible at a high level. See</span>
<span class="sd">                ``hsio.set_io_defaults()`` for more information on each of the</span>
<span class="sd">                settings.</span>

<span class="sd">        Note:</span>
<span class="sd">            The following ``batch`` example builds on the API example results</span>
<span class="sd">            of the `spatial_mod.crop_many_gdf`_ function. Please complete the</span>
<span class="sd">            `spatial_mod.crop_many_gdf`_ example to be sure your directory</span>
<span class="sd">            (i.e., ``base_dir``) is populated with multiple hyperspectral</span>
<span class="sd">            datacubes. The following example will be using datacubes located in</span>
<span class="sd">            the following directory:</span>
<span class="sd">            ``F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf``</span>

<span class="sd">        Example:</span>
<span class="sd">            Load and initialize the ``batch`` module, checking to be sure the</span>
<span class="sd">            directory exists.</span>

<span class="sd">            &gt;&gt;&gt; import os</span>
<span class="sd">            &gt;&gt;&gt; from hs_process import batch</span>
<span class="sd">            &gt;&gt;&gt; base_dir = r&#39;F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf&#39;</span>
<span class="sd">            &gt;&gt;&gt; print(os.path.isdir(base_dir))</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; hsbatch = batch(base_dir, search_ext=&#39;.bip&#39;)  # searches for all files in ``base_dir`` with a &quot;.bip&quot; file extension</span>

<span class="sd">            Use ``batch.cube_to_spectra`` to calculate the *mean* and *standard</span>
<span class="sd">            deviation* across all pixels for each of the datacubes in</span>
<span class="sd">            ``base_dir``.</span>

<span class="sd">            &gt;&gt;&gt; hsbatch.cube_to_spectra(base_dir=base_dir, geotiff=False, out_force=True)</span>
<span class="sd">            Calculating mean spectra: F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\Wells_rep2_20180628_16h56m_pika_gige_7_plot_1011.bip</span>
<span class="sd">            Saving F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\cube_to_spec\Wells_rep2_20180628_16h56m_pika_gige_7_plot_1011-cube-to-spec-mean.spec</span>
<span class="sd">            Calculating mean spectra: F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\Wells_rep2_20180628_16h56m_pika_gige_7_plot_1012.bip</span>
<span class="sd">            Saving F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\cube_to_spec\Wells_rep2_20180628_16h56m_pika_gige_7_plot_1012-cube-to-spec-mean.spec</span>
<span class="sd">            Calculating mean spectra: F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\Wells_rep2_20180628_16h56m_pika_gige_7_plot_1013.bip</span>
<span class="sd">            Saving F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\cube_to_spec\Wells_rep2_20180628_16h56m_pika_gige_7_plot_1013-cube-to-spec-mean.spec</span>
<span class="sd">            ...</span>

<span class="sd">            Use ``seaborn`` to visualize the spectra of plots 1011, 1012, and</span>
<span class="sd">            1013. Notice how ``hsbatch.io.name_plot`` is utilized to retrieve</span>
<span class="sd">            the plot ID, and how the *&quot;history&quot;* tag is referenced from the</span>
<span class="sd">            metadata to determine the number of pixels whose reflectance was</span>
<span class="sd">            averaged to create the mean spectra. Also remember that pixels</span>
<span class="sd">            across the original input image likely represent a combination of</span>
<span class="sd">            soil, vegetation, and shadow.</span>

<span class="sd">            &gt;&gt;&gt; import seaborn as sns</span>
<span class="sd">            &gt;&gt;&gt; import re</span>
<span class="sd">            &gt;&gt;&gt; fname_list = [r&#39;F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\cube_to_spec\Wells_rep2_20180628_16h56m_pika_gige_7_plot_1011-cube-to-spec-mean.spec&#39;,</span>
<span class="sd">                              r&#39;F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\cube_to_spec\Wells_rep2_20180628_16h56m_pika_gige_7_plot_1012-cube-to-spec-mean.spec&#39;,</span>
<span class="sd">                              r&#39;F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\cube_to_spec\Wells_rep2_20180628_16h56m_pika_gige_7_plot_1013-cube-to-spec-mean.spec&#39;]</span>
<span class="sd">            &gt;&gt;&gt; colors = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]</span>
<span class="sd">            &gt;&gt;&gt; for fname, color in zip(fname_list, colors):</span>
<span class="sd">            &gt;&gt;&gt;     hsbatch.io.read_spec(fname)</span>
<span class="sd">            &gt;&gt;&gt;     meta_bands = list(hsbatch.io.tools.meta_bands.values())</span>
<span class="sd">            &gt;&gt;&gt;     data = hsbatch.io.spyfile_spec.load().flatten() * 100</span>
<span class="sd">            &gt;&gt;&gt;     hist = hsbatch.io.spyfile_spec.metadata[&#39;history&#39;]</span>
<span class="sd">            &gt;&gt;&gt;     pix_n = re.search(&#39;&lt;pixel number: (.*)&gt;&#39;, hist).group(1)</span>
<span class="sd">            &gt;&gt;&gt;     ax = sns.lineplot(x=meta_bands, y=data, color=color, label=&#39;Plot &#39;+hsbatch.io.name_plot+&#39; (n=&#39;+pix_n+&#39;)&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ax.set_xlabel(&#39;Wavelength (nm)&#39;, weight=&#39;bold&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ax.set_ylabel(&#39;Reflectance (%)&#39;, weight=&#39;bold&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ax.set_title(r&#39;API Example: `batch.cube_to_spectra`&#39;, weight=&#39;bold&#39;)</span>

<span class="sd">            .. image:: ../img/batch/cube_to_spectra.png</span>

<span class="sd">        .. _spatial_mod.crop_many_gdf: hs_process.spatial_mod.html#hs_process.spatial_mod.crop_many_gdf</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">set_io_defaults</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">,</span> <span class="n">out_force</span><span class="p">,</span> <span class="n">out_ext</span><span class="p">,</span> <span class="n">out_interleave</span><span class="p">,</span>
                                <span class="n">out_byteorder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># base_dir may have been stored to the ``batch`` object</span>
            <span class="n">base_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_dir</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Please set ``fname_list`` or ``base_dir`` to indicate which &#39;</span>
                   <span class="s1">&#39;datacubes should be processed.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">msg</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">force</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># otherwise just overwrites if it exists</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_processed</span><span class="p">(</span><span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span>
                                               <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fname_list</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Calculating mean spectra: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_cube</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">base_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">base_dir_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                        <span class="n">base_dir</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_append</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_file_setup</span><span class="p">(</span>
                        <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>

            <span class="n">spec_mean</span><span class="p">,</span> <span class="n">spec_std</span><span class="p">,</span> <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">mean_datacube</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="p">)</span>

            <span class="n">name_print</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_name_print</span><span class="p">()</span>
            <span class="n">name_label</span> <span class="o">=</span> <span class="p">(</span><span class="n">name_print</span> <span class="o">+</span> <span class="n">name_append</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">interleave</span><span class="p">)</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># because this is specialized, we should make our own history str</span>
            <span class="n">n_pix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="o">.</span><span class="n">nrows</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile</span><span class="o">.</span><span class="n">ncols</span>
            <span class="n">hist_str</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39; -&gt; hs_process.batch.cube_to_spectra[&lt;pixel number: &#39;</span>
                        <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">&gt;]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_pix</span><span class="p">))</span>
            <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;history&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">hist_str</span>
            <span class="n">name_label_spec</span> <span class="o">=</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">name_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                               <span class="s1">&#39;-mean.spec&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">geotiff</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_geotiff</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label</span><span class="p">,</span>
                                    <span class="n">metadata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tools</span><span class="p">)</span>
            <span class="c1"># Now write spec (will change map info on metadata)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_spec</span><span class="p">(</span><span class="n">dir_out</span><span class="p">,</span> <span class="n">name_label_spec</span><span class="p">,</span> <span class="n">spec_mean</span><span class="p">,</span> <span class="n">spec_std</span><span class="p">,</span>
                             <span class="n">metadata</span><span class="p">)</span></div>

<div class="viewcode-block" id="batch.segment_band_math"><a class="viewcode-back" href="../../api/hs_process.batch.html#hs_process.batch.segment_band_math">[docs]</a>    <span class="k">def</span> <span class="nf">segment_band_math</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">search_ext</span><span class="o">=</span><span class="s1">&#39;bip&#39;</span><span class="p">,</span> <span class="n">dir_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">folder_name</span><span class="o">=</span><span class="s1">&#39;band_math&#39;</span><span class="p">,</span> <span class="n">name_append</span><span class="o">=</span><span class="s1">&#39;band-math&#39;</span><span class="p">,</span>
                          <span class="n">geotiff</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ndi&#39;</span><span class="p">,</span> <span class="n">wl1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wl2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">wl3</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">b3</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">list_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plot_out</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">out_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_force</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_ext</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">out_interleave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_byteorder</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Batch processing tool to perform band math on multiple datacubes in the</span>
<span class="sd">        same way. ``batch.segment_band_math`` is typically used prior to</span>
<span class="sd">        ``batch.segment_create_mask`` to generate the images/directory required</span>
<span class="sd">        for the masking process.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            method (``str``): Must be one of &quot;ndi&quot; (normalized difference</span>
<span class="sd">                index), &quot;ratio&quot; (simple ratio index), &quot;derivative&quot;</span>
<span class="sd">                (deriviative-type index), or &quot;mcari2&quot; (modified chlorophyll</span>
<span class="sd">                absorption index2). Indicates what kind of band math should be</span>
<span class="sd">                performed on the input datacube. The &quot;ndi&quot; method leverages</span>
<span class="sd">                ``segment.band_math_ndi()``, the &quot;ratio&quot; method leverages</span>
<span class="sd">                ``segment.band_math_ratio()``, and the &quot;derivative&quot; method</span>
<span class="sd">                leverages ``segment.band_math_derivative()``. Please see the</span>
<span class="sd">                ``segment`` documentation for more information (default:</span>
<span class="sd">                &quot;ndi&quot;).</span>
<span class="sd">            wl1 (``int``, ``float``, or ``list``): the wavelength (or set of</span>
<span class="sd">                wavelengths) to be used as the first parameter of the</span>
<span class="sd">                band math index; if ``list``, then consolidates all</span>
<span class="sd">                bands between two wavelength values by calculating the mean</span>
<span class="sd">                pixel value across all bands in that range (default: ``None``).</span>
<span class="sd">            wl2 (``int``, ``float``, or ``list``): the wavelength (or set of</span>
<span class="sd">                wavelengths) to be used as the second parameter of the</span>
<span class="sd">                band math index; if ``list``, then consolidates all</span>
<span class="sd">                bands between two wavelength values by calculating the mean</span>
<span class="sd">                pixel value across all bands in that range (default: ``None``).</span>
<span class="sd">            b1 (``int``, ``float``, or ``list``): the band (or set of bands) to be</span>
<span class="sd">                used as the first parameter of the band math index;</span>
<span class="sd">                if ``list``, then consolidates all bands between two band values</span>
<span class="sd">                by calculating the mean pixel value across all bands in that</span>
<span class="sd">                range (default: ``None``).</span>
<span class="sd">            b2 (``int``, ``float``, or ``list``): the band (or set of bands) to be</span>
<span class="sd">                used as the second parameter of the band math</span>
<span class="sd">                index; if ``list``, then consolidates all bands between two band</span>
<span class="sd">                values by calculating the mean pixel value across all bands in</span>
<span class="sd">                that range (default: ``None``).</span>
<span class="sd">            list_range (``bool``): Whether bands/wavelengths passed as a list is</span>
<span class="sd">                interpreted as a range of bands (``True``) or for each individual</span>
<span class="sd">                band in the list (``False``). If ``list_range`` is ``True``,</span>
<span class="sd">                ``b1``/``wl1`` and ``b2``/``wl2`` should be lists with two items, and</span>
<span class="sd">                all bands/wavelegths between the two values will be used</span>
<span class="sd">                (default: ``True``).</span>
<span class="sd">            plot_out (``bool``): whether to save a histogram of the band math</span>
<span class="sd">                result (default: ``True``).</span>
<span class="sd">            geotiff (``bool``): whether to save the masked RGB image as a geotiff</span>
<span class="sd">                alongside the masked datacube.</span>

<span class="sd">        Note:</span>
<span class="sd">            The following ``batch`` example builds on the API example results</span>
<span class="sd">            of the `spatial_mod.crop_many_gdf`_ function. Please complete the</span>
<span class="sd">            `spatial_mod.crop_many_gdf`_ example to be sure your directory</span>
<span class="sd">            (i.e., ``base_dir``) is populated with multiple hyperspectral</span>
<span class="sd">            datacubes. The following example will be using datacubes located in</span>
<span class="sd">            the following directory:</span>
<span class="sd">            ``F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf``</span>

<span class="sd">        Example:</span>
<span class="sd">            Load and initialize the ``batch`` module, checking to be sure the</span>
<span class="sd">            directory exists.</span>

<span class="sd">            &gt;&gt;&gt; import os</span>
<span class="sd">            &gt;&gt;&gt; from hs_process import batch</span>
<span class="sd">            &gt;&gt;&gt; base_dir = r&#39;F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf&#39;</span>
<span class="sd">            &gt;&gt;&gt; print(os.path.isdir(base_dir))</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; hsbatch = batch(base_dir, search_ext=&#39;.bip&#39;)  # searches for all files in ``base_dir`` with a &quot;.bip&quot; file extension</span>

<span class="sd">            Use ``batch.segment_band_math`` to compute the MCARI2 (Modified</span>
<span class="sd">            Chlorophyll Absorption Ratio Index Improved; Haboudane et al.,</span>
<span class="sd">            2004) spectral index for each of the datacubes in ``base_dir``. See</span>
<span class="sd">            `Harris Geospatial`_ for more information about the MCARI2 spectral</span>
<span class="sd">            index and references to other spectral indices.</span>

<span class="sd">            &gt;&gt;&gt; folder_name = &#39;band_math_mcari2-800-670-550&#39;  # folder name can be modified to be more descriptive in what type of band math is being performed</span>
<span class="sd">            &gt;&gt;&gt; method = &#39;mcari2&#39;  # must be one of &quot;ndi&quot;, &quot;ratio&quot;, &quot;derivative&quot;, or &quot;mcari2&quot;</span>
<span class="sd">            &gt;&gt;&gt; wl1 = 800</span>
<span class="sd">            &gt;&gt;&gt; wl2 = 670</span>
<span class="sd">            &gt;&gt;&gt; wl3 = 550</span>
<span class="sd">            &gt;&gt;&gt; hsbatch.segment_band_math(base_dir=base_dir, folder_name=folder_name,</span>
<span class="sd">                                          name_append=&#39;band-math&#39;, geotiff=True,</span>
<span class="sd">                                          method=method, wl1=wl1, wl2=wl2, wl3=wl3,</span>
<span class="sd">                                          plot_out=True, out_force=True)</span>
<span class="sd">            Bands used (``b1``): [198]</span>
<span class="sd">            Bands used (``b2``): [135]</span>
<span class="sd">            Bands used (``b3``): [77]</span>
<span class="sd">            Wavelengths used (``b1``): [799.0016]</span>
<span class="sd">            Wavelengths used (``b2``): [669.6752]</span>
<span class="sd">            Wavelengths used (``b3``): [550.6128]</span>
<span class="sd">            Saving F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\band_math_mcari2-800-670-550\Wells_rep2_20180628_16h56m_pika_gige_7_plot_1011-band-math-mcari2-800-670-550.bip</span>
<span class="sd">            ...</span>

<span class="sd">            ``batch.segment_band_math`` creates a new folder in ``base_dir``</span>
<span class="sd">            (in this case the new directory is</span>
<span class="sd">            ``F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\band_math_mcari2-800-670-550``)</span>
<span class="sd">            which contains several data products. The **first** is</span>
<span class="sd">            ``band-math-stats.csv``: a spreadsheet containing summary</span>
<span class="sd">            statistics for each of the image cubes that were processed via</span>
<span class="sd">            ``batch.segment_band_math``; stats include *pixel count*,</span>
<span class="sd">            *mean*, *standard deviation*, *median*, and *percentiles* across</span>
<span class="sd">            all image pixels.</span>

<span class="sd">            **Second** is a ``geotiff`` file for each of the image cubes after the</span>
<span class="sd">            band math processing. This can be opened in *QGIS* to visualize in</span>
<span class="sd">            a spatial reference system, or can be opened using any software</span>
<span class="sd">            that supports floating point *.tif* files.</span>

<span class="sd">            .. image:: ../img/batch/segment_band_math_plot_611-band-math-mcari2-800-670-550_tif.png</span>

<span class="sd">            **Third** is the band math raster saved in the *.hdr* file format.</span>
<span class="sd">            Note that the data conained here should be the same as in the</span>
<span class="sd">            *.tif* file, so it&#39;s a matter of preference as to what may be more</span>
<span class="sd">            useful. This single band *.hdr* can also be opend in *QGIS*.</span>

<span class="sd">            **Fourth** is a histogram of the band math data contained in the</span>
<span class="sd">            image. The histogram illustrates the 90th percentile value, which</span>
<span class="sd">            may be useful in the segmentation step (e.g., see</span>
<span class="sd">            `batch.segment_create_mask`_).</span>

<span class="sd">            .. image:: ../img/batch/segment_band_math_plot_611-band-math-mcari2-800-670-550.png</span>

<span class="sd">        .. _Harris Geospatial: https://www.harrisgeospatial.com/docs/NarrowbandGreenness.html#Modified3</span>
<span class="sd">        .. _batch.segment_create_mask: hs_process.batch.html#hs_process.batch.segment_create_mask</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">set_io_defaults</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">,</span> <span class="n">out_force</span><span class="p">,</span> <span class="n">out_ext</span><span class="p">,</span> <span class="n">out_interleave</span><span class="p">,</span>
                                <span class="n">out_byteorder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># base_dir may have been stored to the ``batch`` object</span>
            <span class="n">base_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_dir</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Please set ``fname_list`` or ``base_dir`` to indicate which &#39;</span>
                   <span class="s1">&#39;datacubes should be processed.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">msg</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>
        <span class="c1"># else fname_list must be passed directly</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ndi&#39;</span><span class="p">:</span>
            <span class="n">append_extra</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;-</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">-</span><span class="si">{2}</span><span class="s1">&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl1</span><span class="p">)),</span>
                                      <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl2</span><span class="p">))))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ratio&#39;</span><span class="p">:</span>
            <span class="n">append_extra</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;-</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">-</span><span class="si">{2}</span><span class="s1">&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl1</span><span class="p">)),</span>
                                      <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl2</span><span class="p">))))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;derivative&#39;</span><span class="p">:</span>
            <span class="n">append_extra</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;-</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">-</span><span class="si">{2}</span><span class="s1">-</span><span class="si">{3}</span><span class="s1">&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl1</span><span class="p">)),</span>
                                      <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl2</span><span class="p">)),</span>
                                      <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl3</span><span class="p">))))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mcari2&#39;</span><span class="p">:</span>
            <span class="n">append_extra</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;-</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">-</span><span class="si">{2}</span><span class="s1">-</span><span class="si">{3}</span><span class="s1">&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl1</span><span class="p">)),</span>
                                      <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl2</span><span class="p">)),</span>
                                      <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">wl3</span><span class="p">))))</span>

        <span class="c1"># checks filenames</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">force</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># otherwise just overwrites if it exists</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_processed</span><span class="p">(</span><span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span>
                                               <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">,</span>
                                               <span class="n">append_extra</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_execute_band_math</span><span class="p">(</span><span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span>
                                <span class="n">name_append</span><span class="p">,</span> <span class="n">geotiff</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">wl1</span><span class="p">,</span> <span class="n">wl2</span><span class="p">,</span>
                                <span class="n">wl3</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">,</span> <span class="n">list_range</span><span class="p">,</span> <span class="n">plot_out</span><span class="p">)</span></div>

<div class="viewcode-block" id="batch.segment_create_mask"><a class="viewcode-back" href="../../api/hs_process.batch.html#hs_process.batch.segment_create_mask">[docs]</a>    <span class="k">def</span> <span class="nf">segment_create_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">search_ext</span><span class="o">=</span><span class="s1">&#39;bip&#39;</span><span class="p">,</span> <span class="n">dir_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mask_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">base_dir_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">folder_name</span><span class="o">=</span><span class="s1">&#39;mask&#39;</span><span class="p">,</span> <span class="n">name_append</span><span class="o">=</span><span class="s1">&#39;mask&#39;</span><span class="p">,</span>
                            <span class="n">geotiff</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mask_thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">mask_percentile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask_side</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span>
                            <span class="n">out_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_force</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_ext</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">out_interleave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_byteorder</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Batch processing tool to create a masked array on many datacubes.</span>
<span class="sd">        ``batch.segment_create_mask`` is typically used after</span>
<span class="sd">        ``batch.segment_band_math`` to mask all the datacubes in a directory</span>
<span class="sd">        based on the result of the band math process.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            mask_thresh (``float`` or ``int``): The value for which to mask the</span>
<span class="sd">                array; should be used with ``side`` parameter (default: ``None``).</span>
<span class="sd">            mask_percentile (``float`` or ``int``): The percentile of pixels to</span>
<span class="sd">                mask; if ``percentile``=95 and ``side``=&#39;lower&#39;, the lowest 95% of</span>
<span class="sd">                pixels will be masked following the band math operation</span>
<span class="sd">                (default: ``None``; range: 0-100).</span>
<span class="sd">            mask_side (``str``): The side of the threshold or percentile for</span>
<span class="sd">                which to apply the mask. Must be either &#39;lower&#39; or &#39;upper&#39;; if</span>
<span class="sd">                &#39;lower&#39;, everything below the threshold/percentile will be</span>
<span class="sd">                masked (default: &#39;lower&#39;).</span>
<span class="sd">            geotiff (``bool``): whether to save the masked RGB image as a geotiff</span>
<span class="sd">                alongside the masked datacube.</span>

<span class="sd">        Note:</span>
<span class="sd">            The following ``batch`` example builds on the API example results</span>
<span class="sd">            of `spatial_mod.crop_many_gdf`_ and `batch.segment_band_math`_.</span>
<span class="sd">            Please complete each of those API examples to be sure your</span>
<span class="sd">            directories (i.e., ``base_dir``, and ``mask_dir``) are populated</span>
<span class="sd">            with image files. The following example will be masking datacubes</span>
<span class="sd">            located in:</span>
<span class="sd">            ``F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf``</span>
<span class="sd">            based on MCARI2 images located in:</span>
<span class="sd">            ``F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\\band_math_mcari2-800-670-550``</span>

<span class="sd">        Example:</span>
<span class="sd">            Load and initialize the ``batch`` module, ensuring ``base_dir`` is</span>
<span class="sd">            a valid directory</span>

<span class="sd">            &gt;&gt;&gt; import os</span>
<span class="sd">            &gt;&gt;&gt; from hs_process import batch</span>
<span class="sd">            &gt;&gt;&gt; base_dir = r&#39;F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf&#39;</span>
<span class="sd">            &gt;&gt;&gt; print(os.path.isdir(base_dir))</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; hsbatch = batch(base_dir, search_ext=&#39;.bip&#39;)  # searches for all files in ``base_dir`` with a &quot;.bip&quot; file extension</span>

<span class="sd">            There must be a single-band image that will be used to determine</span>
<span class="sd">            which datacube pixels are to be masked (determined via the</span>
<span class="sd">            ``mask_dir`` parameter). Point to the directory that contains the</span>
<span class="sd">            MCARI2 images.</span>

<span class="sd">            &gt;&gt;&gt; mask_dir = os.path.join(base_dir, &#39;band_math_mcari2-800-670-550&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(os.path.isdir(mask_dir))</span>
<span class="sd">            True</span>

<span class="sd">            Indicate how the MCARI2 images should be used to determine which</span>
<span class="sd">            hyperspectal pixels are to be masked. The available parameters for</span>
<span class="sd">            controlling this are ``mask_thresh``, ``mask_percentile``, and</span>
<span class="sd">            ``mask_side``. We will mask out all pixels that fall below the</span>
<span class="sd">            MCARI2 90th percentile.</span>

<span class="sd">            &gt;&gt;&gt; mask_percentile = 90</span>
<span class="sd">            &gt;&gt;&gt; mask_side = &#39;lower&#39;</span>

<span class="sd">            Finally, indicate the folder to save the masked datacubes and</span>
<span class="sd">            perform the batch masking via ``batch.segment_create_mask``</span>

<span class="sd">            &gt;&gt;&gt; folder_name = &#39;mask_mcari2_90th&#39;</span>
<span class="sd">            &gt;&gt;&gt; hsbatch.segment_create_mask(base_dir=base_dir, mask_dir=mask_dir,</span>
<span class="sd">                                            folder_name=folder_name,</span>
<span class="sd">                                            name_append=&#39;mask-mcari2-90th&#39;, geotiff=True,</span>
<span class="sd">                                            mask_percentile=mask_percentile,</span>
<span class="sd">                                            mask_side=mask_side)</span>
<span class="sd">            Saving F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\mask_mcari2_90th\Wells_rep2_20180628_16h56m_pika_gige_7_plot_1011-mask-mcari2-90th.bip</span>
<span class="sd">            Saving F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\mask_mcari2_90th\Wells_rep2_20180628_16h56m_pika_gige_7_plot_1011-mask-mcari2-90th-spec-mean.spec</span>
<span class="sd">            ...</span>

<span class="sd">            .. image:: ../img/batch/segment_create_mask_inline.png</span>

<span class="sd">            ``batch.segment_create_mask`` creates a new folder in ``base_dir``</span>
<span class="sd">            named according to the ``folder_name`` parameter</span>
<span class="sd">            (in this case the new directory is</span>
<span class="sd">            ``F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\mask_mcari2_90th``)</span>
<span class="sd">            which contains several data products. The **first** is</span>
<span class="sd">            ``mask-stats.csv``: a spreadsheet containing the band math</span>
<span class="sd">            threshold value for each image file. In this example, the MCARI2</span>
<span class="sd">            value corresponding to the 90th percentile is listed.</span>

<span class="sd">            +------------+------------+-------------+</span>
<span class="sd">            | fname      | plot_id    |lower-pctl-90|</span>
<span class="sd">            +============+============+=============+</span>
<span class="sd">            | ...        | 1011       | 0.83222     |</span>
<span class="sd">            +------------+------------+-------------+</span>
<span class="sd">            | ...        | 1012       | 0.81112     |</span>
<span class="sd">            +------------+------------+-------------+</span>
<span class="sd">            | ...        | 1013       | 0.74394     |</span>
<span class="sd">            +------------+------------+-------------+</span>

<span class="sd">            ...etc.</span>

<span class="sd">            **Second** is a ``geotiff`` file for each of the image cubes after the</span>
<span class="sd">            masking procedure. This can be opened in *QGIS* to visualize in</span>
<span class="sd">            a spatial reference system, or can be opened using any software</span>
<span class="sd">            that supports floating point *.tif* files. The masked pixels are</span>
<span class="sd">            saved as ``null`` values and should render transparently.</span>

<span class="sd">            .. image:: ../img/batch/segment_create_mask_geotiff.png</span>

<span class="sd">            **Third** is the full hyperspectral datacube, also with the masked</span>
<span class="sd">            pixels saved as ``null`` values. Note that the only pixels</span>
<span class="sd">            remaining are the 10% with the highest MCARI2 values.</span>

<span class="sd">            .. image:: ../img/batch/segment_create_mask_datacube.png</span>

<span class="sd">            **Fourth** is the mean spectra across the unmasked datacube pixels.</span>
<span class="sd">            This is illustrated above by the green line plot (the light green</span>
<span class="sd">            shadow represents the standard deviation for each band).</span>

<span class="sd">        .. _Harris Geospatial: https://www.harrisgeospatial.com/docs/NarrowbandGreenness.html#Modified3</span>
<span class="sd">        .. _batch.segment_band_math: hs_process.batch.html#hs_process.batch.segment_band_math</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">set_io_defaults</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">,</span> <span class="n">out_force</span><span class="p">,</span> <span class="n">out_ext</span><span class="p">,</span> <span class="n">out_interleave</span><span class="p">,</span>
                                <span class="n">out_byteorder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># base_dir may have been stored to the ``batch`` object</span>
            <span class="n">base_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_dir</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Please set ``fname_list`` or ``base_dir`` to indicate which &#39;</span>
                   <span class="s1">&#39;datacubes should be processed.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">msg</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">force</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># otherwise just overwrites if it exists</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_processed</span><span class="p">(</span><span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span>
                                               <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_execute_mask</span><span class="p">(</span><span class="n">fname_list</span><span class="p">,</span> <span class="n">mask_dir</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span>
                           <span class="n">name_append</span><span class="p">,</span> <span class="n">geotiff</span><span class="p">,</span> <span class="n">mask_thresh</span><span class="p">,</span>
                           <span class="n">mask_percentile</span><span class="p">,</span> <span class="n">mask_side</span><span class="p">)</span></div>

<div class="viewcode-block" id="batch.spatial_crop"><a class="viewcode-back" href="../../api/hs_process.batch.html#hs_process.batch.spatial_crop">[docs]</a>    <span class="k">def</span> <span class="nf">spatial_crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_sheet</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">search_ext</span><span class="o">=</span><span class="s1">&#39;bip&#39;</span><span class="p">,</span>
                     <span class="n">dir_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">folder_name</span><span class="o">=</span><span class="s1">&#39;spatial_crop&#39;</span><span class="p">,</span> <span class="n">name_append</span><span class="o">=</span><span class="s1">&#39;spatial-crop&#39;</span><span class="p">,</span>
                     <span class="n">geotiff</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">,</span> <span class="n">gdf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">out_force</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_ext</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_interleave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">out_byteorder</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Iterates through a spreadsheet that provides necessary information</span>
<span class="sd">        about how each image should be cropped and how it should be saved.</span>

<span class="sd">        If ``gdf`` is passed (a geopandas.GoeDataFrame polygon file), the</span>
<span class="sd">        cropped images will be shifted to the center of appropriate &quot;plot&quot;</span>
<span class="sd">        polygon.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            fname_sheet (``fname``, ``pandas.DataFrame``, or ``None``, optional):</span>
<span class="sd">                The filename of the spreadsheed that provides the</span>
<span class="sd">                necessary information for fine-tuning the batch process</span>
<span class="sd">                cropping. See below for more information about the required and</span>
<span class="sd">                optional contents of ``fname_sheet`` and how to properly format</span>
<span class="sd">                it. Optionally, ``fname_sheet`` can be a ``Pandas.DataFrame``.</span>
<span class="sd">                If left to ``None``, ``base_dir`` and ``gdf`` must be passed.</span>
<span class="sd">            base_dir (``str``, optional): directory path to search for files to</span>
<span class="sd">                spatially crop; if ``fname_sheet`` is not ``None``,</span>
<span class="sd">                ``base_dir`` will be ignored (default: ``None``).</span>
<span class="sd">            base_dir_out (``str``, optional): output directory of the cropped</span>
<span class="sd">                image (default: ``None``).</span>
<span class="sd">            folder_name (``str``, optional): folder to add to ``base_dir_out``</span>
<span class="sd">                to save all the processed datacubes (default: &#39;spatial_crop&#39;).</span>
<span class="sd">            name_append (``str``, optional): name to append to the filename</span>
<span class="sd">                (default: &#39;spatial-crop&#39;).</span>
<span class="sd">            geotiff (``bool``, optional): whether to save an RGB image as a</span>
<span class="sd">                geotiff alongside the cropped datacube.</span>
<span class="sd">            method (``str``, optional): Must be one of &quot;single&quot; or</span>
<span class="sd">                &quot;many_gdf&quot;. Indicates whether a single plot should be cropped</span>
<span class="sd">                from the input datacube or if many/multiple plots should be</span>
<span class="sd">                cropped from the input datacube. The &quot;single&quot; method leverages</span>
<span class="sd">                `spatial_mod.crop_single()`_ and the &quot;many_gdf&quot; method</span>
<span class="sd">                leverages `spatial_mod.crop_many_gdf()`_. Please</span>
<span class="sd">                see the ``spatial_mod`` documentation for more information</span>
<span class="sd">                (default: &quot;single&quot;).</span>
<span class="sd">            gdf (``geopandas.GeoDataFrame``, optional): the plot names and</span>
<span class="sd">                polygon geometery of each of the plots; &#39;plot&#39; must be used as</span>
<span class="sd">                a column name to identify each of the plots, and should be an</span>
<span class="sd">                integer.</span>
<span class="sd">            out_XXX: Settings for saving the output files can be adjusted here</span>
<span class="sd">                if desired. They are stored in ``batch.io.defaults``, and are</span>
<span class="sd">                therefore accessible at a high level. See</span>
<span class="sd">                `hsio.set_io_defaults()`_ for more information on each of the</span>
<span class="sd">                settings.</span>

<span class="sd">        **Tips and Tricks for** ``fname_sheet`` **when** ``gdf`` **is not passed**</span>

<span class="sd">        If ``gdf`` is not passed, ``fname_sheet`` may have the following</span>
<span class="sd">        required column headings that correspond to the relevant parameters in</span>
<span class="sd">        `spatial_mod.crop_single()`_ and `spatial_mod.crop_many_gdf()`_:</span>

<span class="sd">        #. &quot;directory&quot;</span>
<span class="sd">        #. &quot;name_short&quot;</span>
<span class="sd">        #. &quot;name_long&quot;</span>
<span class="sd">        #. &quot;ext&quot;</span>
<span class="sd">        #. &quot;pix_e_ul&quot;</span>
<span class="sd">        #. &quot;pix_n_ul&quot;.</span>

<span class="sd">        With this minimum input, ``batch.spatial_crop`` will read in each</span>
<span class="sd">        image, crop from the upper left pixel (determined as</span>
<span class="sd">        ``pix_e_ul``/``pix_n_ul``) to the lower right pixel calculated</span>
<span class="sd">        based on ``crop_e_pix``/``crop_n_pix`` (which is the width of the</span>
<span class="sd">        cropped area in units of pixels).</span>

<span class="sd">        Note:</span>
<span class="sd">            ``crop_e_pix`` and ``crop_n_pix`` have default values (see</span>
<span class="sd">            `defaults.crop_defaults()`_), but they can also be passed</span>
<span class="sd">            specifically for each datacube by including appropriate columns in</span>
<span class="sd">            ``fname_sheet`` (which takes precedence over</span>
<span class="sd">            ``defaults.crop_defaults``).</span>

<span class="sd">        ``fname_sheet`` may also have the following optional column headings:</span>

<span class="sd">        #. &quot;crop_e_pix&quot;</span>
<span class="sd">        #. &quot;crop_n_pix&quot;</span>
<span class="sd">        #. &quot;crop_e_m&quot;</span>
<span class="sd">        #. &quot;crop_n_m&quot;</span>
<span class="sd">        #. &quot;buf_e_pix&quot;</span>
<span class="sd">        #. &quot;buf_n_pix&quot;</span>
<span class="sd">        #. &quot;buf_e_m&quot;</span>
<span class="sd">        #. &quot;buf_n_m&quot;</span>
<span class="sd">        #. &quot;plot_id&quot;</span>

<span class="sd">        **More** ``fname_sheet`` **Tips and Tricks**</span>

<span class="sd">        #. These optional inputs passed via ``fname_sheet`` allow more control</span>
<span class="sd">           over exactly how the images are to be cropped. For a more detailed</span>
<span class="sd">           explanation of the information that many of these columns are</span>
<span class="sd">           intended to contain, see the documentation for</span>
<span class="sd">           `spatial_mod.crop_single()`_ and `spatial_mod.crop_many_gdf()`_.</span>
<span class="sd">           Those parameters not referenced should be apparent in the API</span>
<span class="sd">           examples and tutorials.</span>

<span class="sd">        #. If the column names are different in ``fname_sheet`` than described</span>
<span class="sd">           here, `defaults.spat_crop_cols()`_ can be modified to indicate which</span>
<span class="sd">           columns correspond to the relevant information.</span>

<span class="sd">        #. Any other columns can be added to ``fname_sheet``, but</span>
<span class="sd">           ``batch.spatial_crop()`` does not use them in any way.</span>

<span class="sd">        Note:</span>
<span class="sd">            The following ``batch`` example only actually processes *a single*</span>
<span class="sd">            hyperspectral image. If more datacubes were present in</span>
<span class="sd">            ``base_dir``, however, ``batch.spatial_crop`` would process all</span>
<span class="sd">            datacubes that were available.</span>

<span class="sd">        Note:</span>
<span class="sd">            This example uses ``spatial_mod.crop_many_gdf`` to crop many</span>
<span class="sd">            plots from a datacube using a polygon geometry file describing the</span>
<span class="sd">            spatial extent of each plot.</span>

<span class="sd">        Example:</span>

<span class="sd">            Load and initialize the ``batch`` module, checking to be sure the</span>
<span class="sd">            directory exists.</span>

<span class="sd">            &gt;&gt;&gt; import os</span>
<span class="sd">            &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">            &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">            &gt;&gt;&gt; from hs_process import batch</span>
<span class="sd">            &gt;&gt;&gt; base_dir = r&#39;F:\\nigo0024\Documents\hs_process_demo&#39;</span>
<span class="sd">            &gt;&gt;&gt; print(os.path.isdir(base_dir))</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; hsbatch = batch(base_dir, search_ext=&#39;.bip&#39;, dir_level=0)  # searches for all files in ``base_dir`` with a &quot;.bip&quot; file extension</span>

<span class="sd">            Load the plot geometry as a ``geopandas.GeoDataFrame``</span>

<span class="sd">            &gt;&gt;&gt; fname_gdf = r&#39;F:\\nigo0024\Documents\hs_process_demo\plot_bounds_small\plot_bounds.shp&#39;</span>
<span class="sd">            &gt;&gt;&gt; gdf = gpd.read_file(fname_gdf)</span>

<span class="sd">            Perform the spatial cropping using the *&quot;many_gdf&quot;* ``method``.</span>
<span class="sd">            Note that nothing is being bassed to ``fname_sheet`` here, so</span>
<span class="sd">            ``batch.spatial_crop`` is simply going to attempt to crop all plots</span>
<span class="sd">            contained within ``gdf`` that overlap with any datacubes in</span>
<span class="sd">            ``base_dir``. This option does not allow for any flexibility</span>
<span class="sd">            regarding minor adjustments to the cropping procedure (e.g.,</span>
<span class="sd">            offset to the plot location in the datacube relative to the</span>
<span class="sd">            location in the ``gdf``), but it is the most straightforward way to</span>
<span class="sd">            run ``batch.spatial_crop`` because it does not depend on anything</span>
<span class="sd">            to be passed to ``fname_sheet``. It does, however, allow you to</span>
<span class="sd">            adjust the plot buffer relative to ``gdf`` via</span>
<span class="sd">            ``hsbatch.io.defaults.crop_defaults``</span>

<span class="sd">            &gt;&gt;&gt; hsbatch.io.defaults.crop_defaults.buf_e_m = 2</span>
<span class="sd">            &gt;&gt;&gt; hsbatch.io.defaults.crop_defaults.buf_n_m = 0.5</span>
<span class="sd">            &gt;&gt;&gt; hsbatch.io.set_io_defaults(force=True)</span>
<span class="sd">            &gt;&gt;&gt; hsbatch.spatial_crop(base_dir=base_dir, method=&#39;many_gdf&#39;,</span>
<span class="sd">                                     gdf=gdf)</span>
<span class="sd">            Spatially cropping: F:\\nigo0024\Documents\hs_process_demo\Wells_rep2_20180628_16h56m_pika_gige_7-Radiance Conversion-Georectify Airborne Datacube-Convert Radiance Cube to Reflectance from Measured Reference Spectrum.bip</span>
<span class="sd">            Saving F:\\nigo0024\Documents\hs_process_demo\spatial_crop\Wells_rep2_20180628_16h56m_pika_gige_7_1018-spatial-crop.bip</span>
<span class="sd">            Spatially cropping: F:\\nigo0024\Documents\hs_process_demo\Wells_rep2_20180628_16h56m_pika_gige_7-Radiance Conversion-Georectify Airborne Datacube-Convert Radiance Cube to Reflectance from Measured Reference Spectrum.bip</span>
<span class="sd">            Saving F:\\nigo0024\Documents\hs_process_demo\spatial_crop\Wells_rep2_20180628_16h56m_pika_gige_7_918-spatial-crop.bip</span>

<span class="sd">            .. image:: ../img/batch/spatial_crop_inline.png</span>

<span class="sd">            A new folder was created in ``base_dir``</span>
<span class="sd">            - ``F:\\nigo0024\Documents\hs_process_demo\spatial_crop`` - that</span>
<span class="sd">            contains the cropped datacubes and the cropped ``geotiff`` images.</span>
<span class="sd">            The Plot ID from the ``gdf`` is used to name each datacube</span>
<span class="sd">            according to its plot ID. The ``geotiff`` images can be opened in</span>
<span class="sd">            *QGIS* to visualize the images after cropping them.</span>

<span class="sd">            .. image:: ../img/batch/spatial_crop_tifs.png</span>

<span class="sd">            The cropped images were brightened in *QGIS* to emphasize the</span>
<span class="sd">            cropped boundaries. The plot boundaries are overlaid for reference</span>
<span class="sd">            (notice the 2.0 m buffer on the East/West ends and the 0.5 m buffer</span>
<span class="sd">            on the North/South sides).</span>

<span class="sd">        .. _defaults.crop_defaults(): hs_process.defaults.html#hs_process.defaults.crop_defaults</span>
<span class="sd">        .. _defaults.spat_crop_cols(): hs_process.defaults.html#hs_process.defaults.spat_crop_cols</span>
<span class="sd">        .. _hsio.set_io_defaults(): hs_process.hsio.html#hs_process.hsio.set_io_defaults</span>
<span class="sd">        .. _spatial_mod.crop_single(): hs_process.spatial_mod.html#hs_process.spatial_mod.crop_single</span>
<span class="sd">        .. _spatial_mod.crop_many_gdf(): hs_process.spatial_mod.html#hs_process.spatial_mod.crop_many_gdf</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;many_gdf&#39;</span><span class="p">:</span>
            <span class="n">msg1</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Please pass a valid ``geopandas.GeoDataFrame`` if using &#39;</span>
                    <span class="s1">&#39;the &quot;many_gdf&quot; method.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">msg2</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Please be sure the passed ``geopandas.GeoDataFrame`` has a &#39;</span>
                    <span class="s1">&#39;column by the name of &quot;plot&quot;, indicating the plot ID for &#39;</span>
                    <span class="s1">&#39;each polygon geometry if using the &quot;many_gdf&quot; method.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">),</span> <span class="n">msg1</span>
            <span class="k">assert</span> <span class="s1">&#39;plot&#39;</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">msg2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">set_io_defaults</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">,</span> <span class="n">out_force</span><span class="p">,</span> <span class="n">out_ext</span><span class="p">,</span> <span class="n">out_interleave</span><span class="p">,</span>
                                <span class="n">out_byteorder</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fname_sheet</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fname_sheet</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># base_dir may have been stored to the ``batch`` object</span>
            <span class="n">base_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_dir</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Please set ``fname_list`` or ``base_dir`` to indicate which &#39;</span>
                   <span class="s1">&#39;datacubes should be processed.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">msg</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>

        <span class="c1"># Either fname_sheet or fname_list should be None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_crop_execute</span><span class="p">(</span><span class="n">fname_sheet</span><span class="p">,</span> <span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span>
                           <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">,</span> <span class="n">geotiff</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">gdf</span><span class="p">)</span></div>

<div class="viewcode-block" id="batch.spectra_combine"><a class="viewcode-back" href="../../api/hs_process.batch.html#hs_process.batch.spectra_combine">[docs]</a>    <span class="k">def</span> <span class="nf">spectra_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">search_ext</span><span class="o">=</span><span class="s1">&#39;bip&#39;</span><span class="p">,</span> <span class="n">dir_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">out_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_force</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_ext</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">out_interleave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_byteorder</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Batch processing tool to gather all pixels from every image in a</span>
<span class="sd">        directory, compute the mean and standard deviation, and save as a</span>
<span class="sd">        single spectra (i.e., a spectra file is equivalent to a single spectral</span>
<span class="sd">        pixel with no spatial information).</span>

<span class="sd">        Parameters:</span>
<span class="sd">            fname_list (``list``, optional): list of filenames to process; if</span>
<span class="sd">                left to ``None``, will look at ``base_dir``, ``search_ext``,</span>
<span class="sd">                and ``dir_level`` parameters for files to process (default:</span>
<span class="sd">                ``None``).</span>
<span class="sd">            base_dir (``str``, optional): directory path to search for files to</span>
<span class="sd">                spectrally clip; if ``fname_list`` is not ``None``,</span>
<span class="sd">                ``base_dir`` will be ignored (default: ``None``).</span>
<span class="sd">            search_ext (``str``): file format/extension to search for in all</span>
<span class="sd">                directories and subdirectories to determine which files to</span>
<span class="sd">                process; if ``fname_list`` is not ``None``, ``search_ext`` will</span>
<span class="sd">                be ignored (default: &#39;bip&#39;).</span>
<span class="sd">            dir_level (``int``): The number of directory levels to search; if</span>
<span class="sd">                ``None``, searches all directory levels (default: 0).</span>
<span class="sd">            base_dir_out (``str``): directory path to save all processed</span>
<span class="sd">                datacubes; if set to ``None``, a folder named according to the</span>
<span class="sd">                ``folder_name`` parameter is added to ``base_dir`` (default:</span>
<span class="sd">                ``None``).</span>
<span class="sd">            out_XXX: Settings for saving the output files can be adjusted here</span>
<span class="sd">                if desired. They are stored in ``batch.io.defaults, and are</span>
<span class="sd">                therefore accessible at a high level. See</span>
<span class="sd">                ``hsio.set_io_defaults()`` for more information on each of the</span>
<span class="sd">                settings.</span>

<span class="sd">        Note:</span>
<span class="sd">            The following example will load in several small hyperspectral</span>
<span class="sd">            radiance datacubes *(not reflectance)* that were previously cropped</span>
<span class="sd">            manually (via Spectronon software). These datacubes represent the</span>
<span class="sd">            radiance values of grey reference panels that were placed in the</span>
<span class="sd">            field to provide data necessary for converting radiance imagery</span>
<span class="sd">            to reflectance. These particular datacubes were extracted</span>
<span class="sd">            from several different images captured within ~10 minutes of each</span>
<span class="sd">            other.</span>

<span class="sd">        Example:</span>
<span class="sd">            Load and initialize the ``batch`` module, checking to be sure the</span>
<span class="sd">            directory exists.</span>

<span class="sd">            &gt;&gt;&gt; import os</span>
<span class="sd">            &gt;&gt;&gt; from hs_process import batch</span>
<span class="sd">            &gt;&gt;&gt; base_dir = r&#39;F:\\nigo0024\Documents\hs_process_demo\cube_ref_panels&#39;</span>
<span class="sd">            &gt;&gt;&gt; print(os.path.isdir(base_dir))</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; hsbatch = batch(base_dir)</span>

<span class="sd">            Combine all the *radiance* datacubes in the directory via</span>
<span class="sd">            ``batch.spectra_combine``.</span>

<span class="sd">            &gt;&gt;&gt; hsbatch.spectra_combine(base_dir=base_dir, search_ext=&#39;bip&#39;,</span>
<span class="sd">                                        dir_level=0)</span>
<span class="sd">            Combining datacubes/spectra into a single mean spectra.</span>
<span class="sd">            Number of input datacubes/spectra: 7</span>
<span class="sd">            Total number of pixels: 1516</span>
<span class="sd">            Saving F:\\nigo0024\Documents\hs_process_demo\cube_ref_panels\spec_mean_spy.spec</span>

<span class="sd">            Visualize the combined spectra by opening in *Spectronon*. The</span>
<span class="sd">            solid line represents the mean radiance spectra across all pixels</span>
<span class="sd">            and images in ``base_dir``, and the lighter, slightly transparent</span>
<span class="sd">            line represents the standard deviation of the radiance across all</span>
<span class="sd">            pixels and images in ``base_dir``.</span>

<span class="sd">            .. image:: ../img/batch/spectra_combine.png</span>

<span class="sd">            Notice the lower signal at the oxygen absorption region (near 770</span>
<span class="sd">            nm). After converting datacubes to reflectance, it may be</span>
<span class="sd">            desireable to spectrally clip this region (see</span>
<span class="sd">            `spec_mod.spectral_clip()`_)</span>

<span class="sd">        .. _spec_mod.spectral_clip(): hs_process.spec_mod.html#hs_process.spec_mod.spectral_clip</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">set_io_defaults</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">,</span> <span class="n">out_force</span><span class="p">,</span> <span class="n">out_ext</span><span class="p">,</span> <span class="n">out_interleave</span><span class="p">,</span>
                                <span class="n">out_byteorder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># base_dir may have been stored to the ``batch`` object</span>
            <span class="n">base_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_dir</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Please set ``fname_list`` or ``base_dir`` to indicate which &#39;</span>
                   <span class="s1">&#39;datacubes should be processed.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">msg</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_execute_spec_combine</span><span class="p">(</span><span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">)</span></div>

<div class="viewcode-block" id="batch.spectra_to_csv"><a class="viewcode-back" href="../../api/hs_process.batch.html#hs_process.batch.spectra_to_csv">[docs]</a>    <span class="k">def</span> <span class="nf">spectra_to_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">search_ext</span><span class="o">=</span><span class="s1">&#39;spec&#39;</span><span class="p">,</span>
                       <span class="n">dir_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Reads all the ``.spec`` files in a direcory and saves their reflectance</span>
<span class="sd">        information to a ``.csv``. ``batch.spectra_to_csv`` is identical to</span>
<span class="sd">        ``batch.spectra_to_df`` except a ``.csv`` file is saved rather than</span>
<span class="sd">        returning a ``pandas.DataFrame``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            fname_list (``list``, optional): list of filenames to process; if</span>
<span class="sd">                left to ``None``, will look at ``base_dir``, ``search_ext``, and</span>
<span class="sd">                ``dir_level`` parameters for files to process (default: ``None``).</span>
<span class="sd">            base_dir (``str``, optional): directory path to search for files to</span>
<span class="sd">                spectrally clip; if ``fname_list`` is not ``None``, ``base_dir`` will</span>
<span class="sd">                be ignored (default: ``None``).</span>
<span class="sd">            search_ext (``str``): file format/extension to search for in all</span>
<span class="sd">                directories and subdirectories to determine which files to</span>
<span class="sd">                process; if ``fname_list`` is not ``None``, ``search_ext`` will</span>
<span class="sd">                be ignored (default: &#39;bip&#39;).</span>
<span class="sd">            dir_level (``int``): The number of directory levels to search; if</span>
<span class="sd">                ``None``, searches all directory levels (default: 0).</span>
<span class="sd">            base_dir_out (``str``): directory path to save all processed</span>
<span class="sd">                datacubes; if set to ``None``, a folder named according to the</span>
<span class="sd">                ``folder_name`` parameter is added to ``base_dir``</span>

<span class="sd">        Note:</span>
<span class="sd">            The following example builds on the API example results of</span>
<span class="sd">            `batch.segment_band_math()`_ and `batch.segment_create_mask()_.</span>
<span class="sd">            Please complete each of those API examples to be sure your</span>
<span class="sd">            directory (i.e.,</span>
<span class="sd">            ``F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\mask_mcari2_90th``)</span>
<span class="sd">            is populated with image files.</span>

<span class="sd">        Example:</span>
<span class="sd">            Load and initialize the ``batch`` module, checking to be sure the</span>
<span class="sd">            directory exists.</span>

<span class="sd">            &gt;&gt;&gt; import os</span>
<span class="sd">            &gt;&gt;&gt; from hs_process import batch</span>
<span class="sd">            &gt;&gt;&gt; base_dir = r&#39;F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\mask_mcari2_90th&#39;</span>
<span class="sd">            &gt;&gt;&gt; print(os.path.isdir(base_dir))</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; hsbatch = batch(base_dir)</span>

<span class="sd">            Read all the ``.spec`` files in ``base_dir`` and save them to a</span>
<span class="sd">            ``.csv`` file.</span>

<span class="sd">            &gt;&gt;&gt; hsbatch.spectra_to_csv(base_dir=base_dir, search_ext=&#39;spec&#39;,</span>
<span class="sd">                                       dir_level=0)</span>
<span class="sd">            Writing mean spectra to a .csv file.</span>
<span class="sd">            Number of input datacubes/spectra: 40</span>
<span class="sd">            Output file location: F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\mask_mcari2_90th\stats-spectra.csv</span>

<span class="sd">            When ``stats-spectra.csv`` is opened in Microsoft Excel, we can see</span>
<span class="sd">            that each row is a ``.spec`` file from a different plot, and each</span>
<span class="sd">            column is a particular spectral band/wavelength.</span>

<span class="sd">            .. image:: ../img/batch/spectra_to_csv.png</span>

<span class="sd">        .. _batch.segment_band_math(): hs_process.batch.html#hs_process.batch.segment_band_math</span>
<span class="sd">        .. _batch.segment_create_mask(): hs_process.batch.html#hs_process.batch.segment_create_mask</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># base_dir may have been stored to the ``batch`` object</span>
            <span class="n">base_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_dir</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Please set ``fname_list`` or ``base_dir`` to indicate which &#39;</span>
                   <span class="s1">&#39;datacubes should be processed.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">msg</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>

        <span class="n">fname_csv</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="s1">&#39;stats-spectra.csv&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Writing mean spectra to a .csv file.</span><span class="se">\n</span><span class="s1">&#39;</span>
              <span class="s1">&#39;Number of input datacubes/spectra: </span><span class="si">{0}</span><span class="se">\n</span><span class="s1">Output file location: &#39;</span>
              <span class="s1">&#39;</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fname_list</span><span class="p">),</span> <span class="n">fname_csv</span><span class="p">))</span>

        <span class="c1"># load the data from the Spectral Python (SpyFile) object</span>
        <span class="n">df_spec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fname_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_spec</span><span class="p">(</span><span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;.hdr&#39;</span><span class="p">)</span>
            <span class="n">meta_bands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">meta_bands</span>
            <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile_spec</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">name_plot</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">df_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">meta_bands</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;wavelength&#39;</span><span class="p">)</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="n">bands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">meta_bands</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">bands</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;plot_id&#39;</span><span class="p">)</span>
                <span class="n">bands</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;fname&#39;</span><span class="p">)</span>
                <span class="n">df_spec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">bands</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">df_spec_temp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">data</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">df_spec</span> <span class="o">=</span> <span class="n">df_spec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_spec_temp</span><span class="p">)</span>
        <span class="n">df_spec</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">fname_csv</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="batch.spectra_to_df"><a class="viewcode-back" href="../../api/hs_process.batch.html#hs_process.batch.spectra_to_df">[docs]</a>    <span class="k">def</span> <span class="nf">spectra_to_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">search_ext</span><span class="o">=</span><span class="s1">&#39;spec&#39;</span><span class="p">,</span>
                      <span class="n">dir_level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Reads all the .spec files in a direcory and returns their data as a</span>
<span class="sd">        ``pandas.DataFrame`` object. ``batch.spectra_to_df`` is identical to</span>
<span class="sd">        ``batch.spectra_to_csv`` except a ``pandas.DataFrame`` is returned</span>
<span class="sd">        rather than saving a ``.csv`` file.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            fname_list (``list``, optional): list of filenames to process; if</span>
<span class="sd">                left to ``None``, will look at ``base_dir``, ``search_ext``, and</span>
<span class="sd">                ``dir_level`` parameters for files to process (default: ``None``).</span>
<span class="sd">            base_dir (``str``, optional): directory path to search for files to</span>
<span class="sd">                spectrally clip; if ``fname_list`` is not ``None``, ``base_dir`` will</span>
<span class="sd">                be ignored (default: ``None``).</span>
<span class="sd">            search_ext (``str``): file format/extension to search for in all</span>
<span class="sd">                directories and subdirectories to determine which files to</span>
<span class="sd">                process; if ``fname_list`` is not ``None``, ``search_ext`` will</span>
<span class="sd">                be ignored (default: &#39;bip&#39;).</span>
<span class="sd">            dir_level (``int``): The number of directory levels to search; if</span>
<span class="sd">                ``None``, searches all directory levels (default: 0).</span>

<span class="sd">        Note:</span>
<span class="sd">            The following example builds on the API example results of</span>
<span class="sd">            `batch.segment_band_math()`_ and `batch.segment_create_mask()_.</span>
<span class="sd">            Please complete each of those API examples to be sure your</span>
<span class="sd">            directory (i.e.,</span>
<span class="sd">            ``F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\mask_mcari2_90th``)</span>
<span class="sd">            is populated with image files.</span>

<span class="sd">        Example:</span>
<span class="sd">            Load and initialize the ``batch`` module, checking to be sure the</span>
<span class="sd">            directory exists.</span>

<span class="sd">            &gt;&gt;&gt; import os</span>
<span class="sd">            &gt;&gt;&gt; from hs_process import batch</span>
<span class="sd">            &gt;&gt;&gt; base_dir = r&#39;F:\\nigo0024\Documents\hs_process_demo\spatial_mod\crop_many_gdf\mask_mcari2_90th&#39;</span>
<span class="sd">            &gt;&gt;&gt; print(os.path.isdir(base_dir))</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; hsbatch = batch(base_dir)</span>

<span class="sd">            Read all the ``.spec`` files in ``base_dir`` and load them to</span>
<span class="sd">            ``df_spec``, a ``pandas.DataFrame``.</span>

<span class="sd">            &gt;&gt;&gt; df_spec = hsbatch.spectra_to_df(base_dir=base_dir, search_ext=&#39;spec&#39;,</span>
<span class="sd">                                                dir_level=0)</span>
<span class="sd">            Writing mean spectra to a ``pandas.DataFrame``.</span>
<span class="sd">            Number of input datacubes/spectra: 40</span>

<span class="sd">            When visualizing ``df_spe`` in `Spyder`_, we can see that each row</span>
<span class="sd">            is a ``.spec`` file from a different plot, and each column is a</span>
<span class="sd">            particular spectral band.</span>

<span class="sd">            .. image:: ../img/batch/spectra_to_df.png</span>

<span class="sd">            It is somewhat confusing to conceptualize spectral data by band</span>
<span class="sd">            number (as opposed to the wavelenth it represents).</span>
<span class="sd">            ``hs_process.hs_tools.get_band`` can be used to retrieve</span>
<span class="sd">            spectral data for all plots via indexing by wavelength. Say we need</span>
<span class="sd">            to access reflectance at 710 nm for each plot.</span>

<span class="sd">            &gt;&gt;&gt; df_710nm = df_spec[[&#39;fname&#39;, &#39;plot_id&#39;, hsbatch.io.tools.get_band(710)]]</span>

<span class="sd">            .. image:: ../img/batch/spectra_to_df_710nm.png</span>

<span class="sd">        .. _batch.segment_band_math(): hs_process.batch.html#hs_process.batch.segment_band_math</span>
<span class="sd">        .. _batch.segment_create_mask(): hs_process.batch.html#hs_process.batch.segment_create_mask</span>
<span class="sd">        .. _Spyder: https://www.spyder-ide.org/</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># base_dir may have been stored to the ``batch`` object</span>
            <span class="n">base_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_dir</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Please set ``fname_list`` or ``base_dir`` to indicate which &#39;</span>
                   <span class="s1">&#39;datacubes should be processed.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">msg</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Writing mean spectra to a ``pandas.DataFrame``.</span><span class="se">\n</span><span class="s1">&#39;</span>
              <span class="s1">&#39;Number of input datacubes/spectra: </span><span class="si">{0}</span><span class="s1">&#39;</span>
              <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fname_list</span><span class="p">)))</span>

        <span class="c1"># load the data from the Spectral Python (SpyFile) object</span>
        <span class="n">df_spec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fname_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_spec</span><span class="p">(</span><span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;.hdr&#39;</span><span class="p">)</span>
            <span class="n">meta_bands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">meta_bands</span>
            <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">spyfile_spec</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])))</span>
            <span class="n">data</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">name_plot</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">df_spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">meta_bands</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">bands</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;plot_id&#39;</span><span class="p">)</span>
                <span class="n">bands</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;fname&#39;</span><span class="p">)</span>
                <span class="n">df_spec</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">bands</span><span class="p">)</span>
            <span class="n">df_spec_temp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">data</span><span class="p">],</span> <span class="n">columns</span><span class="o">=</span><span class="n">bands</span><span class="p">)</span>
            <span class="n">df_spec</span> <span class="o">=</span> <span class="n">df_spec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df_spec_temp</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df_spec</span><span class="p">[</span><span class="s1">&#39;plot_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">df_spec</span><span class="p">[</span><span class="s1">&#39;plot_id&#39;</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Unable to convert &quot;plot_id&quot; column to numeric type.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df_spec</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="batch.spectral_clip"><a class="viewcode-back" href="../../api/hs_process.batch.html#hs_process.batch.spectral_clip">[docs]</a>    <span class="k">def</span> <span class="nf">spectral_clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">search_ext</span><span class="o">=</span><span class="s1">&#39;bip&#39;</span><span class="p">,</span>
                      <span class="n">dir_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">folder_name</span><span class="o">=</span><span class="s1">&#39;spec_clip&#39;</span><span class="p">,</span>
                      <span class="n">name_append</span><span class="o">=</span><span class="s1">&#39;spec-clip&#39;</span><span class="p">,</span>
                      <span class="n">wl_bands</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">420</span><span class="p">],</span> <span class="p">[</span><span class="mi">760</span><span class="p">,</span> <span class="mi">776</span><span class="p">],</span> <span class="p">[</span><span class="mi">813</span><span class="p">,</span> <span class="mi">827</span><span class="p">],</span> <span class="p">[</span><span class="mi">880</span><span class="p">,</span> <span class="mi">1000</span><span class="p">]],</span>
                      <span class="n">out_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_force</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_ext</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">out_interleave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_byteorder</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Batch processing tool to spectrally clip multiple datacubes in the same</span>
<span class="sd">        way.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            fname_list (``list``, optional): list of filenames to process; if</span>
<span class="sd">                left to ``None``, will look at ``base_dir``, ``search_ext``, and</span>
<span class="sd">                ``dir_level`` parameters for files to process (default: ``None``).</span>
<span class="sd">            base_dir (``str``, optional): directory path to search for files to</span>
<span class="sd">                spectrally clip; if ``fname_list`` is not ``None``, ``base_dir`` will</span>
<span class="sd">                be ignored (default: ``None``).</span>
<span class="sd">            search_ext (``str``): file format/extension to search for in all</span>
<span class="sd">                directories and subdirectories to determine which files to</span>
<span class="sd">                process; if ``fname_list`` is not ``None``, ``search_ext`` will</span>
<span class="sd">                be ignored (default: &#39;bip&#39;).</span>
<span class="sd">            dir_level (``int``): The number of directory levels to search; if</span>
<span class="sd">                ``None``, searches all directory levels (default: 0).</span>
<span class="sd">            base_dir_out (``str``): directory path to save all processed</span>
<span class="sd">                datacubes; if set to ``None``, a folder named according to the</span>
<span class="sd">                ``folder_name`` parameter is added to ``base_dir``</span>
<span class="sd">            folder_name (``str``): folder to add to ``base_dir_out`` to save all</span>
<span class="sd">                the processed datacubes (default: &#39;spec-clip&#39;).</span>
<span class="sd">            name_append (``str``): name to append to the filename (default:</span>
<span class="sd">                &#39;spec-clip&#39;).</span>
<span class="sd">            wl_bands (``list`` or ``list of lists``): minimum and maximum</span>
<span class="sd">                wavelenths to clip from image; if multiple groups of</span>
<span class="sd">                wavelengths should be cut, this should be a list of lists. For</span>
<span class="sd">                example, wl_bands=[760, 776] will clip all bands greater than</span>
<span class="sd">                760.0 nm and less than 776.0 nm;</span>
<span class="sd">                wl_bands = [[0, 420], [760, 776], [813, 827], [880, 1000]]</span>
<span class="sd">                will clip all band less than 420.0 nm, bands greater than 760.0</span>
<span class="sd">                nm and less than 776.0 nm, bands greater than 813.0 nm and less</span>
<span class="sd">                than 827.0 nm, and bands greater than 880 nm (default).</span>
<span class="sd">            out_XXX: Settings for saving the output files can be adjusted here</span>
<span class="sd">                if desired. They are stored in ``batch.io.defaults, and are</span>
<span class="sd">                therefore accessible at a high level. See</span>
<span class="sd">                ``hsio.set_io_defaults()`` for more information on each of the</span>
<span class="sd">                settings.</span>

<span class="sd">        Note:</span>
<span class="sd">            The following ``batch`` example builds on the API example results</span>
<span class="sd">            of the `batch.spatial_crop`_ function. Please complete the</span>
<span class="sd">            `batch.spatial_crop`_ example to be sure your directory</span>
<span class="sd">            (i.e., ``base_dir``) is populated with multiple hyperspectral</span>
<span class="sd">            datacubes. The following example will be using datacubes located in</span>
<span class="sd">            the following directory:</span>
<span class="sd">            ``F:\\nigo0024\Documents\hs_process_demo\spatial_crop``</span>

<span class="sd">        Example:</span>
<span class="sd">            Load and initialize the ``batch`` module, checking to be sure the</span>
<span class="sd">            directory exists.</span>

<span class="sd">            &gt;&gt;&gt; import os</span>
<span class="sd">            &gt;&gt;&gt; from hs_process import batch</span>
<span class="sd">            &gt;&gt;&gt; base_dir = r&#39;F:\\nigo0024\Documents\hs_process_demo\spatial_crop&#39;</span>
<span class="sd">            &gt;&gt;&gt; print(os.path.isdir(base_dir))</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; hsbatch = batch(base_dir, search_ext=&#39;.bip&#39;)  # searches for all files in ``base_dir`` with a &quot;.bip&quot; file extension</span>

<span class="sd">            Use ``batch.spectral_clip`` to clip all spectral bands below</span>
<span class="sd">            *420 nm* and above *880 nm*, as well as the bands near the oxygen</span>
<span class="sd">            absorption (i.e., *760-776 nm*) and water absorption</span>
<span class="sd">            (i.e., *813-827 nm*) regions.</span>

<span class="sd">            &gt;&gt;&gt; hsbatch.spectral_clip(base_dir=base_dir, folder_name=&#39;spec_clip&#39;,</span>
<span class="sd">                                      wl_bands=[[0, 420], [760, 776], [813, 827], [880, 1000]])</span>
<span class="sd">            Processing 40 files. If this is not what is expected, please check if files have already undergone processing. If existing files should be overwritten, be sure to set the ``out_force`` parameter.</span>
<span class="sd">            Spectrally clipping: F:\\nigo0024\Documents\hs_process_demo\spatial_crop\Wells_rep2_20180628_16h56m_pika_gige_7_1011-spatial-crop.bip</span>
<span class="sd">            Saving F:\\nigo0024\Documents\hs_process_demo\spatial_crop\spec_clip\Wells_rep2_20180628_16h56m_pika_gige_7_1011-spec-clip.bip</span>
<span class="sd">            Spectrally clipping: F:\\nigo0024\Documents\hs_process_demo\spatial_crop\Wells_rep2_20180628_16h56m_pika_gige_7_1012-spatial-crop.bip</span>
<span class="sd">            Saving F:\\nigo0024\Documents\hs_process_demo\spatial_crop\spec_clip\Wells_rep2_20180628_16h56m_pika_gige_7_1012-spec-clip.bip</span>
<span class="sd">            ...</span>

<span class="sd">            Use ``seaborn`` to visualize the spectra of a single pixel in one</span>
<span class="sd">            of the processed images.</span>

<span class="sd">            &gt;&gt;&gt; import seaborn as sns</span>
<span class="sd">            &gt;&gt;&gt; fname = os.path.join(base_dir, &#39;Wells_rep2_20180628_16h56m_pika_gige_7_1011-spatial-crop.bip&#39;)</span>
<span class="sd">            &gt;&gt;&gt; hsbatch.io.read_cube(fname)</span>
<span class="sd">            &gt;&gt;&gt; spy_mem = hsbatch.io.spyfile.open_memmap()  # datacube before clipping</span>
<span class="sd">            &gt;&gt;&gt; meta_bands = list(hsbatch.io.tools.meta_bands.values())</span>
<span class="sd">            &gt;&gt;&gt; fname = os.path.join(base_dir, &#39;spec_clip&#39;, &#39;Wells_rep2_20180628_16h56m_pika_gige_7_1011-spec-clip.bip&#39;)</span>
<span class="sd">            &gt;&gt;&gt; hsbatch.io.read_cube(fname)</span>
<span class="sd">            &gt;&gt;&gt; spy_mem_clip = hsbatch.io.spyfile.open_memmap()  # datacube after clipping</span>
<span class="sd">            &gt;&gt;&gt; meta_bands_clip = list(hsbatch.io.tools.meta_bands.values())</span>
<span class="sd">            &gt;&gt;&gt; ax = sns.lineplot(x=meta_bands, y=spy_mem[26][29], label=&#39;Before spectral clipping&#39;, linewidth=3)</span>
<span class="sd">            &gt;&gt;&gt; ax = sns.lineplot(x=meta_bands_clip, y=spy_mem_clip[26][29], label=&#39;After spectral clipping&#39;, ax=ax)</span>
<span class="sd">            &gt;&gt;&gt; ax.set_xlabel(&#39;Wavelength (nm)&#39;, weight=&#39;bold&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ax.set_ylabel(&#39;Reflectance (%)&#39;, weight=&#39;bold&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ax.set_title(r&#39;API Example: `batch.spectral_clip`&#39;, weight=&#39;bold&#39;)</span>

<span class="sd">            .. image:: ../img/batch/spectral_clip_plot.png</span>

<span class="sd">            Notice the spectral areas that were clipped, namely the oxygen and</span>
<span class="sd">            water absorption regions (~770 and ~820 nm, respectively). There</span>
<span class="sd">            is perhaps a lower *signal:noise* ratio in these regions, which was</span>
<span class="sd">            the merit for clipping those bands out.</span>

<span class="sd">        .. _batch.spatial_crop: hs_process.batch.html#hs_process.batch.spatial_crop</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">set_io_defaults</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">,</span> <span class="n">out_force</span><span class="p">,</span> <span class="n">out_ext</span><span class="p">,</span> <span class="n">out_interleave</span><span class="p">,</span>
                                <span class="n">out_byteorder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># base_dir may have been stored to the ``batch`` object</span>
            <span class="n">base_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_dir</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Please set ``fname_list`` or ``base_dir`` to indicate which &#39;</span>
                   <span class="s1">&#39;datacubes should be processed.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">msg</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">force</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># otherwise just overwrites if it exists</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_processed</span><span class="p">(</span><span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span>
                                               <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_execute_spec_clip</span><span class="p">(</span><span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span>
                                    <span class="n">name_append</span><span class="p">,</span> <span class="n">wl_bands</span><span class="p">)</span></div>

<div class="viewcode-block" id="batch.spectral_smooth"><a class="viewcode-back" href="../../api/hs_process.batch.html#hs_process.batch.spectral_smooth">[docs]</a>    <span class="k">def</span> <span class="nf">spectral_smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">search_ext</span><span class="o">=</span><span class="s1">&#39;bip&#39;</span><span class="p">,</span>
                        <span class="n">dir_level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">folder_name</span><span class="o">=</span><span class="s1">&#39;spec_smooth&#39;</span><span class="p">,</span> <span class="n">name_append</span><span class="o">=</span><span class="s1">&#39;spec-smooth&#39;</span><span class="p">,</span>
                        <span class="n">window_size</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">out_dtype</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_force</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_ext</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">out_interleave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">out_byteorder</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Batch processing tool to spectrally smooth multiple datacubes in the</span>
<span class="sd">        same way.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            fname_list (``list``, optional): list of filenames to process; if</span>
<span class="sd">                left to ``None``, will look at ``base_dir``, ``search_ext``, and</span>
<span class="sd">                ``dir_level`` parameters for files to process (default: ``None``).</span>
<span class="sd">            base_dir (``str``, optional): directory path to search for files to</span>
<span class="sd">                spectrally clip; if ``fname_list`` is not ``None``, ``base_dir`` will</span>
<span class="sd">                be ignored (default: ``None``).</span>
<span class="sd">            search_ext (``str``): file format/extension to search for in all</span>
<span class="sd">                directories and subdirectories to determine which files to</span>
<span class="sd">                process; if ``fname_list`` is not ``None``, ``search_ext`` will</span>
<span class="sd">                be ignored (default: &#39;bip&#39;).</span>
<span class="sd">            dir_level (``int``): The number of directory levels to search; if</span>
<span class="sd">                ``None``, searches all directory levels (default: 0).</span>
<span class="sd">            base_dir_out (``str``): directory path to save all processed</span>
<span class="sd">                datacubes; if set to ``None``, a folder named according to the</span>
<span class="sd">                ``folder_name`` parameter is added to ``base_dir``</span>
<span class="sd">            folder_name (``str``): folder to add to ``base_dir_out`` to save all</span>
<span class="sd">                the processed datacubes (default: &#39;spec-smooth&#39;).</span>
<span class="sd">            name_append (``str``): name to append to the filename (default:</span>
<span class="sd">                &#39;spec-smooth&#39;).</span>
<span class="sd">            window_size (``int``): the length of the window; must be an odd</span>
<span class="sd">                integer number (default: 11).</span>
<span class="sd">            order (``int``): the order of the polynomial used in the filtering;</span>
<span class="sd">                must be less than ``window_size`` - 1 (default: 2).</span>
<span class="sd">            stats (``bool``): whether to compute some basic descriptive</span>
<span class="sd">                statistics (mean, st. dev., and coefficient of variation) of</span>
<span class="sd">                the smoothed data array (default: ``False``)</span>
<span class="sd">            out_XXX: Settings for saving the output files can be adjusted here</span>
<span class="sd">                if desired. They are stored in ``batch.io.defaults, and are</span>
<span class="sd">                therefore accessible at a high level. See</span>
<span class="sd">                ``hsio.set_io_defaults()`` for more information on each of the</span>
<span class="sd">                settings.</span>

<span class="sd">        Note:</span>
<span class="sd">            The following ``batch`` example builds on the API example results</span>
<span class="sd">            of the `batch.spatial_crop`_ function. Please complete the</span>
<span class="sd">            `batch.spatial_crop`_ example to be sure your directory</span>
<span class="sd">            (i.e., ``base_dir``) is populated with multiple hyperspectral</span>
<span class="sd">            datacubes. The following example will be using datacubes located in</span>
<span class="sd">            the following directory:</span>
<span class="sd">            ``F:\\nigo0024\Documents\hs_process_demo\spatial_crop``</span>

<span class="sd">        Example:</span>
<span class="sd">            Load and initialize the ``batch`` module, checking to be sure the</span>
<span class="sd">            directory exists.</span>

<span class="sd">            &gt;&gt;&gt; import os</span>
<span class="sd">            &gt;&gt;&gt; from hs_process import batch</span>
<span class="sd">            &gt;&gt;&gt; base_dir = r&#39;F:\\nigo0024\Documents\hs_process_demo\spatial_crop&#39;</span>
<span class="sd">            &gt;&gt;&gt; print(os.path.isdir(base_dir))</span>
<span class="sd">            True</span>
<span class="sd">            &gt;&gt;&gt; hsbatch = batch(base_dir, search_ext=&#39;.bip&#39;)  # searches for all files in ``base_dir`` with a &quot;.bip&quot; file extension</span>

<span class="sd">            Use ``batch.spectral_smooth`` to perform a *Savitzky-Golay*</span>
<span class="sd">            smoothing operation on each image/pixel in ``base_dir``. The</span>
<span class="sd">            ``window_size`` and ``order`` can be adjusted to achieve desired</span>
<span class="sd">            smoothing results.</span>

<span class="sd">            &gt;&gt;&gt; hsbatch.spectral_smooth(base_dir=base_dir, folder_name=&#39;spec_smooth&#39;,</span>
<span class="sd">                                        window_size=11, order=2)</span>
<span class="sd">            Processing 40 files. If this is not what is expected, please check if files have already undergone processing. If existing files should be overwritten, be sure to set the ``out_force`` parameter.</span>
<span class="sd">            Spectrally smoothing: F:\\nigo0024\Documents\hs_process_demo\spatial_crop\Wells_rep2_20180628_16h56m_pika_gige_7_1011-spatial-crop.bip</span>
<span class="sd">            Saving F:\\nigo0024\Documents\hs_process_demo\spatial_crop\spec_smooth\Wells_rep2_20180628_16h56m_pika_gige_7_1011-spec-smooth.bip</span>
<span class="sd">            Spectrally smoothing: F:\\nigo0024\Documents\hs_process_demo\spatial_crop\Wells_rep2_20180628_16h56m_pika_gige_7_1012-spatial-crop.bip</span>
<span class="sd">            Saving F:\\nigo0024\Documents\hs_process_demo\spatial_crop\spec_smooth\Wells_rep2_20180628_16h56m_pika_gige_7_1012-spec-smooth.bip</span>
<span class="sd">            ...</span>

<span class="sd">            Use ``seaborn`` to visualize the spectra of a single pixel in one</span>
<span class="sd">            of the processed images.</span>

<span class="sd">            &gt;&gt;&gt; import seaborn as sns</span>
<span class="sd">            &gt;&gt;&gt; fname = os.path.join(base_dir, &#39;Wells_rep2_20180628_16h56m_pika_gige_7_1011-spatial-crop.bip&#39;)</span>
<span class="sd">            &gt;&gt;&gt; hsbatch.io.read_cube(fname)</span>
<span class="sd">            &gt;&gt;&gt; spy_mem = hsbatch.io.spyfile.open_memmap()  # datacube before smoothing</span>
<span class="sd">            &gt;&gt;&gt; meta_bands = list(hsbatch.io.tools.meta_bands.values())</span>
<span class="sd">            &gt;&gt;&gt; fname = os.path.join(base_dir, &#39;spec_smooth&#39;, &#39;Wells_rep2_20180628_16h56m_pika_gige_7_1011-spec-smooth.bip&#39;)</span>
<span class="sd">            &gt;&gt;&gt; hsbatch.io.read_cube(fname)</span>
<span class="sd">            &gt;&gt;&gt; spy_mem_clip = hsbatch.io.spyfile.open_memmap()  # datacube after smoothing</span>
<span class="sd">            &gt;&gt;&gt; meta_bands_clip = list(hsbatch.io.tools.meta_bands.values())</span>
<span class="sd">            &gt;&gt;&gt; ax = sns.lineplot(x=meta_bands, y=spy_mem[26][29], label=&#39;Before spectral smoothing&#39;, linewidth=3)</span>
<span class="sd">            &gt;&gt;&gt; ax = sns.lineplot(x=meta_bands_clip, y=spy_mem_clip[26][29], label=&#39;After spectral smoothing&#39;, ax=ax)</span>
<span class="sd">            &gt;&gt;&gt; ax.set_xlabel(&#39;Wavelength (nm)&#39;, weight=&#39;bold&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ax.set_ylabel(&#39;Reflectance (%)&#39;, weight=&#39;bold&#39;)</span>
<span class="sd">            &gt;&gt;&gt; ax.set_title(r&#39;API Example: `batch.spectral_smooth`&#39;, weight=&#39;bold&#39;)</span>

<span class="sd">            .. image:: ../img/batch/spectral_smooth_plot.png</span>

<span class="sd">            Notice how the *&quot;choppiness&quot;* of the spectral curve is lessened</span>
<span class="sd">            after the smoothing operation. There are spectral regions that</span>
<span class="sd">            perhaps had a lower *signal:noise* ratio and did not do particularlly</span>
<span class="sd">            well at smoothing (i.e., &lt; 410 nm, ~770 nm, and ~820 nm). It may be</span>
<span class="sd">            wise to perform ``batch.spectral_smooth`` *after*</span>
<span class="sd">            `batch.spectral_clip`_.</span>

<span class="sd">        .. _batch.spatial_crop: hs_process.batch.html#hs_process.batch.spatial_crop</span>
<span class="sd">        .. _batch.spectral_clip: hs_process.batch.html#hs_process.batch.spectral_clip</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">set_io_defaults</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">,</span> <span class="n">out_force</span><span class="p">,</span> <span class="n">out_ext</span><span class="p">,</span> <span class="n">out_interleave</span><span class="p">,</span>
                                <span class="n">out_byteorder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">fname_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># base_dir may have been stored to the ``batch`` object</span>
            <span class="n">base_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_dir</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Please set ``fname_list`` or ``base_dir`` to indicate which &#39;</span>
                   <span class="s1">&#39;datacubes should be processed.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">base_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">msg</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recurs_dir</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">search_ext</span><span class="p">,</span> <span class="n">dir_level</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">defaults</span><span class="o">.</span><span class="n">envi_write</span><span class="o">.</span><span class="n">force</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># otherwise just overwrites if it exists</span>
            <span class="n">fname_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_processed</span><span class="p">(</span><span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span>
                                               <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">)</span>
        <span class="n">df_stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_spec_smooth</span><span class="p">(</span>
                <span class="n">fname_list</span><span class="p">,</span> <span class="n">base_dir_out</span><span class="p">,</span> <span class="n">folder_name</span><span class="p">,</span> <span class="n">name_append</span><span class="p">,</span>
                <span class="n">window_size</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">stats</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">df_stats</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">df_stats</span></div></div>

<span class="c1">#    def combine_kmeans_bandmath(self, fname_sheet, base_dir_out=None,</span>
<span class="c1">#                                folder_name=&#39;mask_combine&#39;,</span>
<span class="c1">#                                name_append=&#39;mask-combine&#39;,</span>
<span class="c1">#                                geotiff=True, kmeans_mask_classes=1,</span>
<span class="c1">#                                kmeans_filter=&#39;mcari2&#39;,</span>
<span class="c1">#                                mask_percentile=90, mask_side=&#39;lower&#39;,</span>
<span class="c1">#                                out_dtype=False, out_force=None, out_ext=False,</span>
<span class="c1">#                                out_interleave=False, out_byteorder=False):</span>
<span class="c1">#        &#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1">#        Parameters:</span>
<span class="c1">#            fname_sheet (``fname`` or ``Pandas.DataFrame): The filename of the</span>
<span class="c1">#                spreadsheed that provides the necessary information for batch</span>
<span class="c1">#                process cropping. See below for more information about the</span>
<span class="c1">#                required and optional contents of ``fname_sheet`` and how to</span>
<span class="c1">#                properly format it. Optionally, ``fname_sheet`` can be a</span>
<span class="c1">#                ``Pandas.DataFrame``</span>
<span class="c1">#            kmeans_mask_classes (``int``): number of K-means classes to mask from</span>
<span class="c1">#                the datacube. By default, the classes with the lowest average</span>
<span class="c1">#                spectral value (e.g., NDVI, GNDVI, MCARI2, etc.; based on</span>
<span class="c1">#                ``kmeans_filter`` parameter) will be masked (default: 1).</span>
<span class="c1">#            kmeans_filter (``str``): the spectral index to base the K-means mask</span>
<span class="c1">#                on. Must be one of &#39;ndvi&#39;, &#39;gndvi&#39;, &#39;ndre&#39;, or &#39;mcari2&#39;. Note</span>
<span class="c1">#                that the K-means aglorithm does not use the in its clustering</span>
<span class="c1">#                algorithm (default: &#39;mcari2&#39;).</span>
<span class="c1">#        Mask steps:</span>
<span class="c1">#            1. load kmeans-stats.csv</span>
<span class="c1">#            2. for each row, load spyfile based on &quot;fname&quot;</span>
<span class="c1">#            3. get class to mask based on:</span>
<span class="c1">#                a. find class with min ndvi: min_class = np.nanmin(class_X_ndvi)</span>
<span class="c1">#            4. mask all pixels of min_class</span>
<span class="c1">#            5. calculate band math (or load images with band math already calculated)</span>
<span class="c1">#            6. mask all pixels below threshold/perecentile</span>
<span class="c1">#                a. if percentile, use pctl to determine number of pixels to keep</span>
<span class="c1">#                b. if pctl = 90, we should keep 10% of total pixels:</span>
<span class="c1">#                    i. find total number of pixels</span>
<span class="c1">#                    ii. calculate what 10% is (155*46 = 7130); 7130 * .1 = 713</span>
<span class="c1">#                    iii. of pixels that are not masked by kmeans, find 713 pixels with highest bandmath</span>
<span class="c1">#                c. if thresh, number doesn&#39;t matter</span>
<span class="c1">#            7. apply the mask to the datacube and save spectra</span>
<span class="c1">#        &#39;&#39;&#39;</span>
<span class="c1">#        self.io.set_io_defaults(out_dtype, out_force, out_ext, out_interleave,</span>
<span class="c1">#                                out_byteorder)</span>
<span class="c1">#</span>
<span class="c1">#        if isinstance(fname_sheet, pd.DataFrame):</span>
<span class="c1">#            df_kmeans = fname_sheet.copy()</span>
<span class="c1">#            fname_sheet = &#39;dataframe passed&#39;</span>
<span class="c1">#        elif os.path.splitext(fname_sheet)[1] == &#39;.csv&#39;:</span>
<span class="c1">#            df_kmeans = pd.read_csv(fname_sheet)</span>
<span class="c1">#</span>
<span class="c1">#        msg = (&#39;&lt;kmeans_filter&gt; must be one of &quot;ndvi&quot;, &quot;gndvi&quot;, &quot;ndre&quot;, &#39;</span>
<span class="c1">#               &#39;or &quot;mcari2&quot;.&#39;)</span>
<span class="c1">#        assert kmeans_filter in [&#39;ndvi&#39;, &#39;gndvi&#39;, &#39;ndre&#39;, &#39;mcari2&#39;], msg</span>
<span class="c1">#        filter_str = &#39;_{0}&#39;.format(kmeans_filter)</span>
<span class="c1">#        filter_cols = [col for col in df_kmeans.columns if filter_str in col]</span>
<span class="c1">#</span>
<span class="c1">#        bandmath_pctl_str = &#39;{0}_pctl&#39;.format(kmeans_filter)</span>
<span class="c1">#        bandmath_side_str = &#39;{0}_side&#39;.format(kmeans_filter)</span>
<span class="c1">#        columns = [&#39;fname&#39;, &#39;kmeans_class&#39;, &#39;kmeans_nonmasked_pct&#39;,</span>
<span class="c1">#                   bandmath_pctl_str, bandmath_side_str, &#39;total_nonmasked_pct&#39;]</span>
<span class="c1">#        df_stats = pd.DataFrame(columns=columns)</span>
<span class="c1">#</span>
<span class="c1">#        if self.io.defaults.envi_write.force is False:  # otherwise just overwrites if it exists</span>
<span class="c1">#            fname_list = df_kmeans[&#39;fname&#39;].tolist()</span>
<span class="c1">#            fname_list = self._check_processed(fname_list, base_dir_out,</span>
<span class="c1">#                                               folder_name, name_append)</span>
<span class="c1">#            df_kmeans = df_kmeans[df_kmeans[&#39;plot_id&#39;].isin(fname_list)]</span>
<span class="c1">#</span>
<span class="c1">#        for idx, row in df_kmeans.iterrows():  # using stats-kmeans.csv</span>
<span class="c1">#            class_mask = self._get_class_mask(row, filter_cols,</span>
<span class="c1">#                                              n_classes=kmeans_mask_classes)</span>
<span class="c1">#            fname = row[&#39;fname&#39;]</span>
<span class="c1">#            self.io.read_cube(fname)</span>
<span class="c1">#            if base_dir_out is None:</span>
<span class="c1">#                dir_out, name_append = self._save_file_setup(</span>
<span class="c1">#                        os.path.dirname(fname), folder_name, name_append)</span>
<span class="c1">#            else:</span>
<span class="c1">#                dir_out, name_append = self._save_file_setup(</span>
<span class="c1">#                        base_dir_out, folder_name, name_append)</span>
<span class="c1">#            name_print = self._get_name_print()</span>
<span class="c1">#</span>
<span class="c1">#            dir_search = os.path.join(self.io.base_dir, &#39;kmeans&#39;)</span>
<span class="c1">#            array_kmeans, metadata_kmeans = self._get_array_similar(dir_search)</span>
<span class="c1">#            dir_search = os.path.join(self.io.base_dir, &#39;band_math&#39;)</span>
<span class="c1">#            array_bandmath, metadata_bandmath = self._get_array_similar(</span>
<span class="c1">#                    dir_search)</span>
<span class="c1">#</span>
<span class="c1">#            array_kmeans, metadata_kmeans = self.io.tools.mask_array(</span>
<span class="c1">#                    array_kmeans, metadata_kmeans, thresh=class_mask,</span>
<span class="c1">#                    side=None)  # when side=None, masks the exact match</span>
<span class="c1">#            kmeans_pct = (100 * (array_kmeans.count() /</span>
<span class="c1">#                            (array_kmeans.shape[0]*array_kmeans.shape[1])))</span>
<span class="c1">#</span>
<span class="c1">#            # by adding the kmeans mask, hstools.mask_array will consider that</span>
<span class="c1">#            # mask when masking by bandmath values (applicable for percentile)</span>
<span class="c1">#            array_bandmath = np.ma.masked_array(</span>
<span class="c1">#                    array_bandmath, mask=array_kmeans.mask)</span>
<span class="c1">#            mask_combined, metadata_bandmath = self.io.tools.mask_array(</span>
<span class="c1">#                    array_bandmath, metadata_bandmath,</span>
<span class="c1">#                    percentile=mask_percentile, side=mask_side)</span>
<span class="c1">#            total_pct = (100 * (mask_combined.count() /</span>
<span class="c1">#                            (mask_combined.shape[0]*mask_combined.shape[1])))</span>
<span class="c1">#            spec_mean, spec_std, datacube_masked = self.io.tools.mean_datacube(</span>
<span class="c1">#                    self.io.spyfile, mask_combined)</span>
<span class="c1">#</span>
<span class="c1">#            data = [os.path.basename(fname), class_mask, kmeans_pct,</span>
<span class="c1">#                    mask_percentile, mask_side, total_pct]</span>
<span class="c1">#            df_stats_temp = pd.DataFrame(data=[data], columns=columns)</span>
<span class="c1">#            df_stats = df_stats.append(df_stats_temp)</span>
<span class="c1">#            name_label = (name_print + name_append + &#39;.&#39; +</span>
<span class="c1">#                          self.io.defaults.envi_write.interleave)</span>
<span class="c1">#            metadata = self.io.spyfile.metadata.copy()</span>
<span class="c1">#            # because this is specialized, we should make our own history str</span>
<span class="c1">#            hist_str = (&quot; -&gt; hs_process.batch.combine_kmeans_bandmath[&lt;&quot;</span>
<span class="c1">#                        &quot;label: &#39;fname_sheet?&#39; value:{0}; &quot;</span>
<span class="c1">#                        &quot;label: &#39;kmeans_class?&#39; value:{1}; &quot;</span>
<span class="c1">#                        &quot;label: &#39;mask_percentile?&#39; value:{2}; &quot;</span>
<span class="c1">#                        &quot;label: &#39;mask_side?&#39; value:{3}&gt;]&quot;</span>
<span class="c1">#                        &quot;&quot;.format(fname_sheet, class_mask, mask_percentile,</span>
<span class="c1">#                                  mask_side))</span>
<span class="c1">#            metadata[&#39;history&#39;] += hist_str</span>
<span class="c1">#            self._write_datacube(dir_out, name_label, datacube_masked,</span>
<span class="c1">#                                 metadata)</span>
<span class="c1">#</span>
<span class="c1">#            name_label_spec = (os.path.splitext(name_label)[0] +</span>
<span class="c1">#                               &#39;-spec-mean.spec&#39;)</span>
<span class="c1">#            self._write_spec(dir_out, name_label_spec, spec_mean, spec_std,</span>
<span class="c1">#                             metadata)</span>
<span class="c1">#        fname_stats = os.path.join(dir_out, name_append[1:] + &#39;-stats.csv&#39;)</span>
<span class="c1">#        if os.path.isfile(fname_stats) and self.io.defaults.envi_write.force is False:</span>
<span class="c1">#            df_stats_in = pd.read_csv(fname_stats)</span>
<span class="c1">#            df_stats = df_stats_in.append(df_stats)</span>
<span class="c1">#        df_stats.to_csv(fname_stats, index=False)</span>

<span class="c1">#    def segment_kmeans(self, fname_list=None, base_dir=None, search_ext=&#39;bip&#39;,</span>
<span class="c1">#                       dir_level=0, base_dir_out=None, folder_name=&#39;kmeans&#39;,</span>
<span class="c1">#                       name_append=&#39;kmeans&#39;, geotiff=True,</span>
<span class="c1">#                       n_classes=3, max_iter=100, plot_out=True,</span>
<span class="c1">#                       out_dtype=False, out_force=None,</span>
<span class="c1">#                       out_ext=False, out_interleave=False,</span>
<span class="c1">#                       out_byteorder=False):</span>
<span class="c1">#        &#39;&#39;&#39;</span>
<span class="c1">#        Batch processing tool to perform kmeans clustering on multiple</span>
<span class="c1">#        datacubes in the same way (uses Spectral Python kmeans tool).</span>
<span class="c1">#</span>
<span class="c1">#        Parameters:</span>
<span class="c1">#            n_classes (``int``): number of classes to cluster (default: 3).</span>
<span class="c1">#            max_iter (``int``): maximum iterations before terminating process</span>
<span class="c1">#                (default: 100).</span>
<span class="c1">#            plot_out (``bool``): whether to save a line plot of the spectra for</span>
<span class="c1">#                each class (default: ``True``).</span>
<span class="c1">#            geotiff (``bool``): whether to save the masked RGB image as a geotiff</span>
<span class="c1">#                alongside the masked datacube.</span>
<span class="c1">#        &#39;&#39;&#39;</span>
<span class="c1">#        self.io.set_io_defaults(out_dtype, out_force, out_ext, out_interleave,</span>
<span class="c1">#                                out_byteorder)</span>
<span class="c1">#        if fname_list is None and base_dir is not None:</span>
<span class="c1">#            fname_list = self._recurs_dir(base_dir, search_ext, dir_level)</span>
<span class="c1">#        elif fname_list is None and base_dir is None:</span>
<span class="c1">#            # base_dir may have been stored to the ``batch`` object</span>
<span class="c1">#            base_dir = self.base_dir</span>
<span class="c1">#            msg = (&#39;Please set ``fname_list`` or ``base_dir`` to indicate which &#39;</span>
<span class="c1">#                   &#39;datacubes should be processed.\n&#39;)</span>
<span class="c1">#            assert base_dir is not None, msg</span>
<span class="c1">#            fname_list = self._recurs_dir(base_dir, search_ext, dir_level)</span>
<span class="c1">#</span>
<span class="c1">#        if self.io.defaults.envi_write.force is False:  # otherwise just overwrites if it exists</span>
<span class="c1">#            fname_list = self._check_processed(fname_list, base_dir_out,</span>
<span class="c1">#                                               folder_name, name_append)</span>
<span class="c1">#        self._execute_kmeans(fname_list, base_dir_out, folder_name,</span>
<span class="c1">#                             name_append, geotiff, n_classes, max_iter,</span>
<span class="c1">#                             plot_out)</span>
<span class="c1">#</span>
<span class="c1">##        if fname_list is not None:</span>
<span class="c1">##            self._execute_kmeans(fname_list, base_dir_out, folder_name,</span>
<span class="c1">##                                 name_append, geotiff, n_classes, max_iter,</span>
<span class="c1">##                                 plot_out, mask_soil=False)</span>
<span class="c1">##        elif base_dir is not None:</span>
<span class="c1">##            fname_list = self._recurs_dir(base_dir, search_ext, dir_level)</span>
<span class="c1">##            self._execute_kmeans(fname_list, base_dir_out, folder_name,</span>
<span class="c1">##                                 name_append, geotiff, n_classes, max_iter,</span>
<span class="c1">##                                 plot_out, mask_soil=False)</span>
<span class="c1">##        else:  # fname_list and base_dir are both ``None``</span>
<span class="c1">##            # base_dir may have been stored to the ``batch`` object</span>
<span class="c1">##            base_dir = self.base_dir</span>
<span class="c1">##            msg = (&#39;Please set ``fname_list`` or ``base_dir`` to indicate which &#39;</span>
<span class="c1">##                   &#39;datacubes should be processed.\n&#39;)</span>
<span class="c1">##            assert base_dir is not None, msg</span>
<span class="c1">##            fname_list = self._recurs_dir(base_dir, search_ext, dir_level)</span>
<span class="c1">##            self._execute_kmeans(fname_list, base_dir_out, folder_name,</span>
<span class="c1">##                                 name_append, geotiff, n_classes, max_iter,</span>
<span class="c1">##                                 plot_out, mask_soil=False)</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2020, Tyler J. Nigon.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>